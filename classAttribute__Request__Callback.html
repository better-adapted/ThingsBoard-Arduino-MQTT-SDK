<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ThingsBoard Client SDK: Attribute_Request_Callback&lt; MaxAttributes &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">ThingsBoard Client SDK<span id="projectnumber">&#160;0.13.0</span>
   </div>
   <div id="projectbrief">Client SDK to connect with ThingsBoard IoT Platform from IoT devices (Arduino, Espressif, etc.)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classAttribute__Request__Callback-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Attribute_Request_Callback&lt; MaxAttributes &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Client-side or shared attributes request callback wrapper, contains the needed configuration settings to create the request that should be sent to the server. Which attribute scope will be requested from either client-side or shared, is decided depending on which method the class instance is passed to as an argument. If that method is the Client_Attributes_Request() then the passed attributes are requested and if they exist are received from the client scope, but if that method is the Shared_Attributes_Request() then the passed attributes are requested and if they exist are received from the shared scope instead. To achieve that some internal member variables get set automatically by those methods, the first one being a string to differentiate which attribute scope was requested and the second being the id of the mqtt request, where the response by the server will use the same id, which makes it easy to know which method intially requested the data and should now receive it. Documentation about the specific use of Requesting client-side or shared scope atrributes in ThingsBoard can be found here <a href="https://thingsboard.io/docs/reference/mqtt-api/#request-attribute-values-from-the-server">https://thingsboard.io/docs/reference/mqtt-api/#request-attribute-values-from-the-server</a>.  
 <a href="classAttribute__Request__Callback.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Attribute__Request__Callback_8h_source.html">Attribute_Request_Callback.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Attribute_Request_Callback&lt; MaxAttributes &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classAttribute__Request__Callback.png" usemap="#Attribute_5FRequest_5FCallback_3C_20MaxAttributes_20_3E_map" alt=""/>
  <map id="Attribute_5FRequest_5FCallback_3C_20MaxAttributes_20_3E_map" name="Attribute_5FRequest_5FCallback_3C_20MaxAttributes_20_3E_map">
<area href="classCallback.html" alt="Callback&lt; void, JsonObjectConst const &amp; &gt;" shape="rect" coords="0,0,267,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a54f31ad9b6704885302369b8ae615f86"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAttribute__Request__Callback.html#a54f31ad9b6704885302369b8ae615f86">Attribute_Request_Callback</a> ()=default</td></tr>
<tr class="memdesc:a54f31ad9b6704885302369b8ae615f86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs empty callback, will result in never being called. Internals are simply default constructed as nullptr.  <a href="classAttribute__Request__Callback.html#a54f31ad9b6704885302369b8ae615f86">More...</a><br /></td></tr>
<tr class="separator:a54f31ad9b6704885302369b8ae615f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa415ea17dabe00eb01477f4bd62bb9e5"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aa415ea17dabe00eb01477f4bd62bb9e5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAttribute__Request__Callback.html#aa415ea17dabe00eb01477f4bd62bb9e5">Attribute_Request_Callback</a> (<a class="el" href="classCallback.html#af45120af2b2d91741aa94c707989d9db">function</a> callback, Args const &amp;... args)</td></tr>
<tr class="memdesc:aa415ea17dabe00eb01477f4bd62bb9e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs callback, will be called upon client-side or shared attribute request arrival where the given multiple requested client-side or shared attributes were sent by the cloud and received by the client. Directly forwards the given arguments to the overloaded vector constructor, meaning all combinatons of arguments that would initalize a vector can be used to call this constructor. See possible vector constructors <a href="https://en.cppreference.com/w/cpp/container/vector/vector">https://en.cppreference.com/w/cpp/container/vector/vector</a>, for the possible passed parameters. The possibilites mainly consist out of the fill constructor, where a value and a number n is given and then that many elements of the value will be copied into or be created with their default value, or out of the range constructor where we can pass an interator the start of another data container and to the end of the data container (last element + 1) and then every element between those iteratos will be copied, in the same order as in the original data container. The last option is a copy constructor where we pass a vector and the values of that vector will be copied into our buffer.  <a href="classAttribute__Request__Callback.html#aa415ea17dabe00eb01477f4bd62bb9e5">More...</a><br /></td></tr>
<tr class="separator:aa415ea17dabe00eb01477f4bd62bb9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ebf45c0270202608363728c2a9494e"><td class="memItemLeft" align="right" valign="top">const size_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAttribute__Request__Callback.html#af2ebf45c0270202608363728c2a9494e">Get_Request_ID</a> () const</td></tr>
<tr class="memdesc:af2ebf45c0270202608363728c2a9494e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the unique request identifier that is connected to the original request, and will be later used to verifiy which <a class="el" href="classAttribute__Request__Callback.html" title="Client-side or shared attributes request callback wrapper, contains the needed configuration settings...">Attribute_Request_Callback</a> is connected to which received client-side or shared attributes.  <a href="classAttribute__Request__Callback.html#af2ebf45c0270202608363728c2a9494e">More...</a><br /></td></tr>
<tr class="separator:af2ebf45c0270202608363728c2a9494e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e826dfb081804c81e101c00d1eabab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAttribute__Request__Callback.html#a21e826dfb081804c81e101c00d1eabab">Set_Request_ID</a> (size_t const &amp;request_id)</td></tr>
<tr class="memdesc:a21e826dfb081804c81e101c00d1eabab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the unique request identifier that is connected to the original request, and will be later used to verifiy which <a class="el" href="classAttribute__Request__Callback.html" title="Client-side or shared attributes request callback wrapper, contains the needed configuration settings...">Attribute_Request_Callback</a> is connected to which received client-side or shared attributes. Not meant for external use, because the value is overwritten by the ThingsBoard class once the class instance has been passed as a parameter anyway, this is the case because only the ThingsBoard class knows the current request id that this callback will be attached too.  <a href="classAttribute__Request__Callback.html#a21e826dfb081804c81e101c00d1eabab">More...</a><br /></td></tr>
<tr class="separator:a21e826dfb081804c81e101c00d1eabab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe9e4809d411906cfd2a63c16112eed8"><td class="memItemLeft" align="right" valign="top">char const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAttribute__Request__Callback.html#afe9e4809d411906cfd2a63c16112eed8">Get_Attribute_Key</a> () const</td></tr>
<tr class="memdesc:afe9e4809d411906cfd2a63c16112eed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the response key of the key-value pair, that we expect the client-side or shared attribute payload json data to be contained in.  <a href="classAttribute__Request__Callback.html#afe9e4809d411906cfd2a63c16112eed8">More...</a><br /></td></tr>
<tr class="separator:afe9e4809d411906cfd2a63c16112eed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac542a2a35170732c58c33e4d0e7ff7ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAttribute__Request__Callback.html#ac542a2a35170732c58c33e4d0e7ff7ef">Set_Attribute_Key</a> (char const *const attribute_key)</td></tr>
<tr class="memdesc:ac542a2a35170732c58c33e4d0e7ff7ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the response key of the key-value pair, that we expect the client-side or shared attribute payload json data to be contained in Not meant for external use, because the value is overwritten by the ThingsBoard class once the class instance has been passed as a parameter anyway, this is the case because the json key changes depending on if we request client-side or shared scope attributes and which type we requests depends on which method the class instance is passed as a parameter to.  <a href="classAttribute__Request__Callback.html#ac542a2a35170732c58c33e4d0e7ff7ef">More...</a><br /></td></tr>
<tr class="separator:ac542a2a35170732c58c33e4d0e7ff7ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66554b6988e6f9d684183556e39514bd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classArray.html">Array</a>&lt; char const *, MaxAttributes &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAttribute__Request__Callback.html#a66554b6988e6f9d684183556e39514bd">Get_Attributes</a> () const</td></tr>
<tr class="memdesc:a66554b6988e6f9d684183556e39514bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all the requested client-side or shared attributes that will result, in the subscribed method being called when the response with their current value is sent from the cloud and received by the client.  <a href="classAttribute__Request__Callback.html#a66554b6988e6f9d684183556e39514bd">More...</a><br /></td></tr>
<tr class="separator:a66554b6988e6f9d684183556e39514bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9258846ef54b83e6dbb3096f6a9c7a3f"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a9258846ef54b83e6dbb3096f6a9c7a3f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAttribute__Request__Callback.html#a9258846ef54b83e6dbb3096f6a9c7a3f">Set_Attributes</a> (Args const &amp;... args)</td></tr>
<tr class="memdesc:a9258846ef54b83e6dbb3096f6a9c7a3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all the requested client-side or shared attributes that will result, in the subscribed method being called when the response with their current value is sent from the cloud and received by the client. Directly forwards the given arguments to the overloaded vector assign method, meaning all combinatons of arguments that can call the assign method on a vector can be used to call this method. See possible overloaded vector assign methods <a href="https://en.cppreference.com/w/cpp/container/vector/assign">https://en.cppreference.com/w/cpp/container/vector/assign</a>, for the possible passed parameters. The possibilites mainly consist out of the fill assign method, where a value and a number n is given and then that many elements of the value will be copied into or be created with their default value, or out of the range assign method where we can pass an interator the start of another data container and to the end of the data container (last element + 1) and then every element between those iteratos will be copied, in the same order as in the original data container. The last option is a copy assign method where we pass a vector and the values of that vector will be copied into our buffer.  <a href="classAttribute__Request__Callback.html#a9258846ef54b83e6dbb3096f6a9c7a3f">More...</a><br /></td></tr>
<tr class="separator:a9258846ef54b83e6dbb3096f6a9c7a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classCallback"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classCallback')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classCallback.html">Callback&lt; void, JsonObjectConst const &amp; &gt;</a></td></tr>
<tr class="memitem:aa75102e61e75e3e3c42ab77a3f2b7b9d inherit pub_methods_classCallback"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallback.html#aa75102e61e75e3e3c42ab77a3f2b7b9d">Callback</a> ()=default</td></tr>
<tr class="memdesc:aa75102e61e75e3e3c42ab77a3f2b7b9d inherit pub_methods_classCallback"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs empty callback, will result in never being called. Internals are simply default constructed as nullptr.  <a href="classCallback.html#aa75102e61e75e3e3c42ab77a3f2b7b9d">More...</a><br /></td></tr>
<tr class="separator:aa75102e61e75e3e3c42ab77a3f2b7b9d inherit pub_methods_classCallback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3538ebd04b7d27f9a476c1c4401a18b4 inherit pub_methods_classCallback"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallback.html#a3538ebd04b7d27f9a476c1c4401a18b4">Callback</a> (<a class="el" href="classCallback.html#af45120af2b2d91741aa94c707989d9db">function</a> callback, char const *const message)</td></tr>
<tr class="memdesc:a3538ebd04b7d27f9a476c1c4401a18b4 inherit pub_methods_classCallback"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs base callback, will be called upon specific arrival of json message where the requested data was sent by the cloud and received by the client.  <a href="classCallback.html#a3538ebd04b7d27f9a476c1c4401a18b4">More...</a><br /></td></tr>
<tr class="separator:a3538ebd04b7d27f9a476c1c4401a18b4 inherit pub_methods_classCallback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f4936c591a7f35ff16bb98ff34a91aa inherit pub_methods_classCallback"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallback.html#a6f4936c591a7f35ff16bb98ff34a91aa">Call_Callback</a> (argumentTypes const &amp;... arguments) const</td></tr>
<tr class="memdesc:a6f4936c591a7f35ff16bb98ff34a91aa inherit pub_methods_classCallback"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the callback that was subscribed, when this class instance was initally created.  <a href="classCallback.html#a6f4936c591a7f35ff16bb98ff34a91aa">More...</a><br /></td></tr>
<tr class="separator:a6f4936c591a7f35ff16bb98ff34a91aa inherit pub_methods_classCallback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e51dfc3b4e33631b2f0b6ff38bc277c inherit pub_methods_classCallback"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallback.html#a8e51dfc3b4e33631b2f0b6ff38bc277c">Set_Callback</a> (<a class="el" href="classCallback.html#af45120af2b2d91741aa94c707989d9db">function</a> callback)</td></tr>
<tr class="memdesc:a8e51dfc3b4e33631b2f0b6ff38bc277c inherit pub_methods_classCallback"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the callback method that will be called upon data arrival with the given data that was received serialized into the given argument types, used to change the callback initally passed or to set the callback if it was not passed as an argument initally.  <a href="classCallback.html#a8e51dfc3b4e33631b2f0b6ff38bc277c">More...</a><br /></td></tr>
<tr class="separator:a8e51dfc3b4e33631b2f0b6ff38bc277c inherit pub_methods_classCallback"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classCallback"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classCallback')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classCallback.html">Callback&lt; void, JsonObjectConst const &amp; &gt;</a></td></tr>
<tr class="memitem:af45120af2b2d91741aa94c707989d9db inherit pub_types_classCallback"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallback.html#af45120af2b2d91741aa94c707989d9db">function</a> = std::function&lt; void(argumentTypes... arguments)&gt;</td></tr>
<tr class="memdesc:af45120af2b2d91741aa94c707989d9db inherit pub_types_classCallback"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCallback.html" title="General purpose callback wrapper. Expects either c-style or c++ style function pointer,...">Callback</a> signature.  <a href="classCallback.html#af45120af2b2d91741aa94c707989d9db">More...</a><br /></td></tr>
<tr class="separator:af45120af2b2d91741aa94c707989d9db inherit pub_types_classCallback"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;size_t MaxAttributes = Default_Attributes_Amount&gt;<br />
class Attribute_Request_Callback&lt; MaxAttributes &gt;</div><p >Client-side or shared attributes request callback wrapper, contains the needed configuration settings to create the request that should be sent to the server. Which attribute scope will be requested from either client-side or shared, is decided depending on which method the class instance is passed to as an argument. If that method is the Client_Attributes_Request() then the passed attributes are requested and if they exist are received from the client scope, but if that method is the Shared_Attributes_Request() then the passed attributes are requested and if they exist are received from the shared scope instead. To achieve that some internal member variables get set automatically by those methods, the first one being a string to differentiate which attribute scope was requested and the second being the id of the mqtt request, where the response by the server will use the same id, which makes it easy to know which method intially requested the data and should now receive it. Documentation about the specific use of Requesting client-side or shared scope atrributes in ThingsBoard can be found here <a href="https://thingsboard.io/docs/reference/mqtt-api/#request-attribute-values-from-the-server">https://thingsboard.io/docs/reference/mqtt-api/#request-attribute-values-from-the-server</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MaxAttributes</td><td>Maximum amount of attributes that will ever be requested with this instance of the class, allows to use an array on the stack in the background. Be aware though the size set in this template and the size passed to the ThingsBoard MaxAttributes template need to be the same or the value in this class lower, if not some of the requested keys may be lost, default = Default_Attributes_Amount (5) </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a54f31ad9b6704885302369b8ae615f86" name="a54f31ad9b6704885302369b8ae615f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54f31ad9b6704885302369b8ae615f86">&#9670;&#160;</a></span>Attribute_Request_Callback() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxAttributes = Default_Attributes_Amount&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAttribute__Request__Callback.html">Attribute_Request_Callback</a>&lt; MaxAttributes &gt;<a class="el" href="classAttribute__Request__Callback.html">::Attribute_Request_Callback</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs empty callback, will result in never being called. Internals are simply default constructed as nullptr. </p>

</div>
</div>
<a id="aa415ea17dabe00eb01477f4bd62bb9e5" name="aa415ea17dabe00eb01477f4bd62bb9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa415ea17dabe00eb01477f4bd62bb9e5">&#9670;&#160;</a></span>Attribute_Request_Callback() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxAttributes = Default_Attributes_Amount&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAttribute__Request__Callback.html">Attribute_Request_Callback</a>&lt; MaxAttributes &gt;<a class="el" href="classAttribute__Request__Callback.html">::Attribute_Request_Callback</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCallback.html#af45120af2b2d91741aa94c707989d9db">function</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args const &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs callback, will be called upon client-side or shared attribute request arrival where the given multiple requested client-side or shared attributes were sent by the cloud and received by the client. Directly forwards the given arguments to the overloaded vector constructor, meaning all combinatons of arguments that would initalize a vector can be used to call this constructor. See possible vector constructors <a href="https://en.cppreference.com/w/cpp/container/vector/vector">https://en.cppreference.com/w/cpp/container/vector/vector</a>, for the possible passed parameters. The possibilites mainly consist out of the fill constructor, where a value and a number n is given and then that many elements of the value will be copied into or be created with their default value, or out of the range constructor where we can pass an interator the start of another data container and to the end of the data container (last element + 1) and then every element between those iteratos will be copied, in the same order as in the original data container. The last option is a copy constructor where we pass a vector and the values of that vector will be copied into our buffer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...Args</td><td>Holds the multiple arguments that will simply be forwarded to the vector constructor and therefore allow to use every overloaded vector constructor without having to implement them </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td><a class="el" href="classCallback.html" title="General purpose callback wrapper. Expects either c-style or c++ style function pointer,...">Callback</a> method that will be called upon data arrival with the given data that was received serialized into a JsonDocument </td></tr>
    <tr><td class="paramname">...args</td><td>Arguments that will be forwarded into the overloaded vector constructor see <a href="https://en.cppreference.com/w/cpp/container/vector/vector">https://en.cppreference.com/w/cpp/container/vector/vector</a> for more information </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afe9e4809d411906cfd2a63c16112eed8" name="afe9e4809d411906cfd2a63c16112eed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe9e4809d411906cfd2a63c16112eed8">&#9670;&#160;</a></span>Get_Attribute_Key()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxAttributes = Default_Attributes_Amount&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char const  * <a class="el" href="classAttribute__Request__Callback.html">Attribute_Request_Callback</a>&lt; MaxAttributes &gt;::Get_Attribute_Key </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the response key of the key-value pair, that we expect the client-side or shared attribute payload json data to be contained in. </p>
<dl class="section return"><dt>Returns</dt><dd>Key that the data is saved into, "client" for client-side attributes and "shared" for shared scope attributes </dd></dl>

</div>
</div>
<a id="a66554b6988e6f9d684183556e39514bd" name="a66554b6988e6f9d684183556e39514bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66554b6988e6f9d684183556e39514bd">&#9670;&#160;</a></span>Get_Attributes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxAttributes = Default_Attributes_Amount&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classArray.html">Array</a>&lt; char const *, MaxAttributes &gt; &amp; <a class="el" href="classAttribute__Request__Callback.html">Attribute_Request_Callback</a>&lt; MaxAttributes &gt;::Get_Attributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets all the requested client-side or shared attributes that will result, in the subscribed method being called when the response with their current value is sent from the cloud and received by the client. </p>
<dl class="section return"><dt>Returns</dt><dd>Requested client-side or shared attributes </dd></dl>

</div>
</div>
<a id="af2ebf45c0270202608363728c2a9494e" name="af2ebf45c0270202608363728c2a9494e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2ebf45c0270202608363728c2a9494e">&#9670;&#160;</a></span>Get_Request_ID()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxAttributes = Default_Attributes_Amount&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t &amp; <a class="el" href="classAttribute__Request__Callback.html">Attribute_Request_Callback</a>&lt; MaxAttributes &gt;::Get_Request_ID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the unique request identifier that is connected to the original request, and will be later used to verifiy which <a class="el" href="classAttribute__Request__Callback.html" title="Client-side or shared attributes request callback wrapper, contains the needed configuration settings...">Attribute_Request_Callback</a> is connected to which received client-side or shared attributes. </p>
<dl class="section return"><dt>Returns</dt><dd>Unique identifier connected to the requested client-side or shared attributes </dd></dl>

</div>
</div>
<a id="ac542a2a35170732c58c33e4d0e7ff7ef" name="ac542a2a35170732c58c33e4d0e7ff7ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac542a2a35170732c58c33e4d0e7ff7ef">&#9670;&#160;</a></span>Set_Attribute_Key()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxAttributes = Default_Attributes_Amount&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAttribute__Request__Callback.html">Attribute_Request_Callback</a>&lt; MaxAttributes &gt;::Set_Attribute_Key </td>
          <td>(</td>
          <td class="paramtype">char const *const&#160;</td>
          <td class="paramname"><em>attribute_key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the response key of the key-value pair, that we expect the client-side or shared attribute payload json data to be contained in Not meant for external use, because the value is overwritten by the ThingsBoard class once the class instance has been passed as a parameter anyway, this is the case because the json key changes depending on if we request client-side or shared scope attributes and which type we requests depends on which method the class instance is passed as a parameter to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attribute_key</td><td>Key that the data is saved into, "client" for client-side attributes and "shared" for shared scope attributes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9258846ef54b83e6dbb3096f6a9c7a3f" name="a9258846ef54b83e6dbb3096f6a9c7a3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9258846ef54b83e6dbb3096f6a9c7a3f">&#9670;&#160;</a></span>Set_Attributes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxAttributes = Default_Attributes_Amount&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAttribute__Request__Callback.html">Attribute_Request_Callback</a>&lt; MaxAttributes &gt;::Set_Attributes </td>
          <td>(</td>
          <td class="paramtype">Args const &amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all the requested client-side or shared attributes that will result, in the subscribed method being called when the response with their current value is sent from the cloud and received by the client. Directly forwards the given arguments to the overloaded vector assign method, meaning all combinatons of arguments that can call the assign method on a vector can be used to call this method. See possible overloaded vector assign methods <a href="https://en.cppreference.com/w/cpp/container/vector/assign">https://en.cppreference.com/w/cpp/container/vector/assign</a>, for the possible passed parameters. The possibilites mainly consist out of the fill assign method, where a value and a number n is given and then that many elements of the value will be copied into or be created with their default value, or out of the range assign method where we can pass an interator the start of another data container and to the end of the data container (last element + 1) and then every element between those iteratos will be copied, in the same order as in the original data container. The last option is a copy assign method where we pass a vector and the values of that vector will be copied into our buffer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">...Args</td><td>Holds the multiple arguments that will simply be forwarded to the vector assign method and therefore allow to use every overloaded vector assign without having to implement them </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...args</td><td>Arguments that will be forwarded into the overloaded vector assign method see <a href="https://en.cppreference.com/w/cpp/container/vector/assign">https://en.cppreference.com/w/cpp/container/vector/assign</a> for more information </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21e826dfb081804c81e101c00d1eabab" name="a21e826dfb081804c81e101c00d1eabab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21e826dfb081804c81e101c00d1eabab">&#9670;&#160;</a></span>Set_Request_ID()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t MaxAttributes = Default_Attributes_Amount&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAttribute__Request__Callback.html">Attribute_Request_Callback</a>&lt; MaxAttributes &gt;::Set_Request_ID </td>
          <td>(</td>
          <td class="paramtype">size_t const &amp;&#160;</td>
          <td class="paramname"><em>request_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the unique request identifier that is connected to the original request, and will be later used to verifiy which <a class="el" href="classAttribute__Request__Callback.html" title="Client-side or shared attributes request callback wrapper, contains the needed configuration settings...">Attribute_Request_Callback</a> is connected to which received client-side or shared attributes. Not meant for external use, because the value is overwritten by the ThingsBoard class once the class instance has been passed as a parameter anyway, this is the case because only the ThingsBoard class knows the current request id that this callback will be attached too. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">request_id</td><td>Unqiue identifier of the request for client-side or shared attributes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="Attribute__Request__Callback_8h_source.html">Attribute_Request_Callback.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
