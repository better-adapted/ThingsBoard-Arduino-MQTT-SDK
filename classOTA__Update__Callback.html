<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ThingsBoard Client SDK: OTA_Update_Callback Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">ThingsBoard Client SDK<span id="projectnumber">&#160;0.13.0</span>
   </div>
   <div id="projectbrief">Client SDK to connect with ThingsBoard IoT Platform from IoT devices (Arduino, Espressif, etc.)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classOTA__Update__Callback-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">OTA_Update_Callback Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Over the air firmware update callback wrapper, contains the needed configuration settings to create the request that should be sent to the server. Documentation about the specific use of Over the air updates in ThingsBoard can be found here <a href="https://thingsboard.io/docs/user-guide/ota-updates/">https://thingsboard.io/docs/user-guide/ota-updates/</a>.  
 <a href="classOTA__Update__Callback.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="OTA__Update__Callback_8h_source.html">OTA_Update_Callback.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for OTA_Update_Callback:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classOTA__Update__Callback.png" usemap="#OTA_5FUpdate_5FCallback_map" alt=""/>
  <map id="OTA_5FUpdate_5FCallback_map" name="OTA_5FUpdate_5FCallback_map">
<area href="classCallback.html" alt="Callback&lt; void, bool const &amp; &gt;" shape="rect" coords="0,0,191,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae441eee469d2953b967a54883193c5aa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOTA__Update__Callback.html#ae441eee469d2953b967a54883193c5aa">returnType</a> = void</td></tr>
<tr class="memdesc:ae441eee469d2953b967a54883193c5aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">OTA firmware update callback signature.  <a href="classOTA__Update__Callback.html#ae441eee469d2953b967a54883193c5aa">More...</a><br /></td></tr>
<tr class="separator:ae441eee469d2953b967a54883193c5aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf7a1f7a282dca68c39b5acfa750c64"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOTA__Update__Callback.html#aaaf7a1f7a282dca68c39b5acfa750c64">progressArgumentType</a> = size_t const &amp;</td></tr>
<tr class="separator:aaaf7a1f7a282dca68c39b5acfa750c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8850470eebc62db4537446dbb3b000"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOTA__Update__Callback.html#a2c8850470eebc62db4537446dbb3b000">progressFn</a> = std::function&lt; <a class="el" href="classOTA__Update__Callback.html#ae441eee469d2953b967a54883193c5aa">returnType</a>(<a class="el" href="classOTA__Update__Callback.html#aaaf7a1f7a282dca68c39b5acfa750c64">progressArgumentType</a> current, <a class="el" href="classOTA__Update__Callback.html#aaaf7a1f7a282dca68c39b5acfa750c64">progressArgumentType</a> total)&gt;</td></tr>
<tr class="separator:a2c8850470eebc62db4537446dbb3b000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classCallback"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classCallback')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classCallback.html">Callback&lt; void, bool const &amp; &gt;</a></td></tr>
<tr class="memitem:af45120af2b2d91741aa94c707989d9db inherit pub_types_classCallback"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallback.html#af45120af2b2d91741aa94c707989d9db">function</a> = std::function&lt; void(argumentTypes... arguments)&gt;</td></tr>
<tr class="memdesc:af45120af2b2d91741aa94c707989d9db inherit pub_types_classCallback"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCallback.html" title="General purpose callback wrapper. Expects either c-style or c++ style function pointer,...">Callback</a> signature.  <a href="classCallback.html#af45120af2b2d91741aa94c707989d9db">More...</a><br /></td></tr>
<tr class="separator:af45120af2b2d91741aa94c707989d9db inherit pub_types_classCallback"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3fa7b00234f950f8f529569456171dae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOTA__Update__Callback.html#a3fa7b00234f950f8f529569456171dae">OTA_Update_Callback</a> ()=default</td></tr>
<tr class="memdesc:a3fa7b00234f950f8f529569456171dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs empty callback, will result in never being called. Internals are simply default constructed as nullptr.  <a href="classOTA__Update__Callback.html#a3fa7b00234f950f8f529569456171dae">More...</a><br /></td></tr>
<tr class="separator:a3fa7b00234f950f8f529569456171dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467931d04bd9adacd7e75d9f2452c511"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOTA__Update__Callback.html#a467931d04bd9adacd7e75d9f2452c511">OTA_Update_Callback</a> (<a class="el" href="classCallback.html#af45120af2b2d91741aa94c707989d9db">function</a> endCb, char const *const currFwTitle, char const *const currFwVersion, <a class="el" href="classIUpdater.html">IUpdater</a> *const updater, uint8_t const &amp;chunkRetries=<a class="el" href="OTA__Update__Callback_8h.html#a38c3ced5cfe0c4c30998f5173fb131ed">CHUNK_RETRIES</a>, uint16_t const &amp;chunkSize=<a class="el" href="OTA__Update__Callback_8h.html#aa5627c8879830b626f3cbd7ea043a22f">CHUNK_SIZE</a>, uint64_t const &amp;timeout=<a class="el" href="OTA__Update__Callback_8h.html#a1ec9afcfcdafeb514df4921836aac784">REQUEST_TIMEOUT</a>)</td></tr>
<tr class="memdesc:a467931d04bd9adacd7e75d9f2452c511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs callbacks that will be called when the OTA firmware data, has been completly sent by the cloud, received by the client and written to the flash partition.  <a href="classOTA__Update__Callback.html#a467931d04bd9adacd7e75d9f2452c511">More...</a><br /></td></tr>
<tr class="separator:a467931d04bd9adacd7e75d9f2452c511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47944d3572d89af232935296d7e8857"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOTA__Update__Callback.html#aa47944d3572d89af232935296d7e8857">OTA_Update_Callback</a> (<a class="el" href="classOTA__Update__Callback.html#a2c8850470eebc62db4537446dbb3b000">progressFn</a> progressCb, <a class="el" href="classCallback.html#af45120af2b2d91741aa94c707989d9db">function</a> endCb, char const *const currFwTitle, char const *const currFwVersion, <a class="el" href="classIUpdater.html">IUpdater</a> *const updater, uint8_t const &amp;chunkRetries=<a class="el" href="OTA__Update__Callback_8h.html#a38c3ced5cfe0c4c30998f5173fb131ed">CHUNK_RETRIES</a>, uint16_t const &amp;chunkSize=<a class="el" href="OTA__Update__Callback_8h.html#aa5627c8879830b626f3cbd7ea043a22f">CHUNK_SIZE</a>, uint64_t const &amp;timeout=<a class="el" href="OTA__Update__Callback_8h.html#a1ec9afcfcdafeb514df4921836aac784">REQUEST_TIMEOUT</a>)</td></tr>
<tr class="memdesc:aa47944d3572d89af232935296d7e8857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs callbacks that will be called when the OTA firmware data, has been completly sent by the cloud, received by the client and written to the flash partition as well as callback.  <a href="classOTA__Update__Callback.html#aa47944d3572d89af232935296d7e8857">More...</a><br /></td></tr>
<tr class="separator:aa47944d3572d89af232935296d7e8857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231b484988f8d9cbf05f8da93fdd2f76"><td class="memTemplParams" colspan="2">template&lt;typename Logger &gt; </td></tr>
<tr class="memitem:a231b484988f8d9cbf05f8da93fdd2f76"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classOTA__Update__Callback.html#ae441eee469d2953b967a54883193c5aa">returnType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classOTA__Update__Callback.html#a231b484988f8d9cbf05f8da93fdd2f76">Call_Progress_Callback</a> (<a class="el" href="classOTA__Update__Callback.html#aaaf7a1f7a282dca68c39b5acfa750c64">progressArgumentType</a> current, <a class="el" href="classOTA__Update__Callback.html#aaaf7a1f7a282dca68c39b5acfa750c64">progressArgumentType</a> total) const</td></tr>
<tr class="memdesc:a231b484988f8d9cbf05f8da93fdd2f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the progress callback that was subscribed, when this class instance was initally created.  <a href="classOTA__Update__Callback.html#a231b484988f8d9cbf05f8da93fdd2f76">More...</a><br /></td></tr>
<tr class="separator:a231b484988f8d9cbf05f8da93fdd2f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefff7f533e630fd4b1491a96043d9858"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOTA__Update__Callback.html#aefff7f533e630fd4b1491a96043d9858">Set_Progress_Callback</a> (<a class="el" href="classOTA__Update__Callback.html#a2c8850470eebc62db4537446dbb3b000">progressFn</a> progressCb)</td></tr>
<tr class="memdesc:aefff7f533e630fd4b1491a96043d9858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the progress callback method that will be called every time our current progress of downloading the complete firmware data changed, this makes it possible to display a progress bar or signal easily how far we are in the current downloading process.  <a href="classOTA__Update__Callback.html#aefff7f533e630fd4b1491a96043d9858">More...</a><br /></td></tr>
<tr class="separator:aefff7f533e630fd4b1491a96043d9858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89711fdf8ea13750f8e7e4de4ca06af"><td class="memItemLeft" align="right" valign="top">char const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOTA__Update__Callback.html#af89711fdf8ea13750f8e7e4de4ca06af">Get_Firmware_Title</a> () const</td></tr>
<tr class="memdesc:af89711fdf8ea13750f8e7e4de4ca06af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current firmware title, used to decide if an OTA firmware update is already installed and therefore should not be downladed, this is only done if the title of the update and the current firmware title are the same because if they are not then this firmware is meant for another device type.  <a href="classOTA__Update__Callback.html#af89711fdf8ea13750f8e7e4de4ca06af">More...</a><br /></td></tr>
<tr class="separator:af89711fdf8ea13750f8e7e4de4ca06af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1bb9c850716c581f6325bb7ec113aef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOTA__Update__Callback.html#ab1bb9c850716c581f6325bb7ec113aef">Set_Firmware_Title</a> (const char *currFwTitle)</td></tr>
<tr class="memdesc:ab1bb9c850716c581f6325bb7ec113aef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current firmware title, used to decide if an OTA firmware update is already installed and therefore should not be downladed, this is only done if the title of the update and the current firmware title are the same because if they are not then this firmware is meant for another device type.  <a href="classOTA__Update__Callback.html#ab1bb9c850716c581f6325bb7ec113aef">More...</a><br /></td></tr>
<tr class="separator:ab1bb9c850716c581f6325bb7ec113aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5ec36b5f1c86619f224bf3b027b2f7"><td class="memItemLeft" align="right" valign="top">char const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOTA__Update__Callback.html#acc5ec36b5f1c86619f224bf3b027b2f7">Get_Firmware_Version</a> () const</td></tr>
<tr class="memdesc:acc5ec36b5f1c86619f224bf3b027b2f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current firmware version, used to decide if an OTA firmware update is already installed and therefore should not be downladed, this is only done if the version of the update and the current firmware version are different, because if they are not then we would download the same firmware as is already on the device.  <a href="classOTA__Update__Callback.html#acc5ec36b5f1c86619f224bf3b027b2f7">More...</a><br /></td></tr>
<tr class="separator:acc5ec36b5f1c86619f224bf3b027b2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a95942a7ce63e55e610b2f650b8cf9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOTA__Update__Callback.html#a7a95942a7ce63e55e610b2f650b8cf9a">Set_Firmware_Version</a> (const char *currFwVersion)</td></tr>
<tr class="memdesc:a7a95942a7ce63e55e610b2f650b8cf9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current firmware version, used to decide if an OTA firmware update is already installed and therefore should not be downladed, this is only done if the version of the update and the current firmware version are different, because if they are not then we would download the same firmware as is already on the device.  <a href="classOTA__Update__Callback.html#a7a95942a7ce63e55e610b2f650b8cf9a">More...</a><br /></td></tr>
<tr class="separator:a7a95942a7ce63e55e610b2f650b8cf9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641a07bad07a09e1159c69b927de1d31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIUpdater.html">IUpdater</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOTA__Update__Callback.html#a641a07bad07a09e1159c69b927de1d31">Get_Updater</a> () const</td></tr>
<tr class="memdesc:a641a07bad07a09e1159c69b927de1d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the updater implementation, used to write the actual firmware data into the needed memory location, so it can be used to reboot the given device with that new flashed firmware.  <a href="classOTA__Update__Callback.html#a641a07bad07a09e1159c69b927de1d31">More...</a><br /></td></tr>
<tr class="separator:a641a07bad07a09e1159c69b927de1d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f6f6c5dba7c3587c1e255f85e8dd67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOTA__Update__Callback.html#a68f6f6c5dba7c3587c1e255f85e8dd67">Set_Updater</a> (<a class="el" href="classIUpdater.html">IUpdater</a> *updater)</td></tr>
<tr class="memdesc:a68f6f6c5dba7c3587c1e255f85e8dd67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the updater implementation, used to write the actual firmware data into the needed memory location, so it can be used to reboot the given device with that new flashed firmware.  <a href="classOTA__Update__Callback.html#a68f6f6c5dba7c3587c1e255f85e8dd67">More...</a><br /></td></tr>
<tr class="separator:a68f6f6c5dba7c3587c1e255f85e8dd67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c93286b00bdb5a08ef6e11a861495c0"><td class="memItemLeft" align="right" valign="top">uint8_t const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOTA__Update__Callback.html#a3c93286b00bdb5a08ef6e11a861495c0">Get_Chunk_Retries</a> () const</td></tr>
<tr class="memdesc:a3c93286b00bdb5a08ef6e11a861495c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the amount of times we attempt to download each chunk of the OTA firmware binary file, if the download fails because it times out, doesn't let itself write into flash memory, ... the retries are decreased by 1 until we hit 0, if that is the case then we instead stop the OTA firmware update completely.  <a href="classOTA__Update__Callback.html#a3c93286b00bdb5a08ef6e11a861495c0">More...</a><br /></td></tr>
<tr class="separator:a3c93286b00bdb5a08ef6e11a861495c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db00c12808ebfdfbd2abebbfe74ce07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOTA__Update__Callback.html#a4db00c12808ebfdfbd2abebbfe74ce07">Set_Chunk_Retries</a> (uint8_t const &amp;chunkRetries)</td></tr>
<tr class="memdesc:a4db00c12808ebfdfbd2abebbfe74ce07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the amount of times we attempt to download each chunk of the OTA firmware binary file, if the download fails because it times out, doesn't let itself write into flash memory, ... the retries are decreased by 1 until we hit 0, if that is the case then we instead stop the OTA firmware update completely.  <a href="classOTA__Update__Callback.html#a4db00c12808ebfdfbd2abebbfe74ce07">More...</a><br /></td></tr>
<tr class="separator:a4db00c12808ebfdfbd2abebbfe74ce07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d0cb2ac659c673cf6a063c041d3221"><td class="memItemLeft" align="right" valign="top">uint16_t const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOTA__Update__Callback.html#a29d0cb2ac659c673cf6a063c041d3221">Get_Chunk_Size</a> () const</td></tr>
<tr class="memdesc:a29d0cb2ac659c673cf6a063c041d3221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the chunks that the firmware binary data will be split into, increased chunkSize might speed up the process by a little bit, but requires more heap memory,.  <a href="classOTA__Update__Callback.html#a29d0cb2ac659c673cf6a063c041d3221">More...</a><br /></td></tr>
<tr class="separator:a29d0cb2ac659c673cf6a063c041d3221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185d04638cc0a4c6a2c30694b73d4bc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOTA__Update__Callback.html#a185d04638cc0a4c6a2c30694b73d4bc2">Set_Chunk_Size</a> (uint16_t const &amp;chunkSize)</td></tr>
<tr class="memdesc:a185d04638cc0a4c6a2c30694b73d4bc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of the chunks that the firmware binary data will be split into, increased chunkSize might speed up the process by a little bit, but requires more heap memory,.  <a href="classOTA__Update__Callback.html#a185d04638cc0a4c6a2c30694b73d4bc2">More...</a><br /></td></tr>
<tr class="separator:a185d04638cc0a4c6a2c30694b73d4bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbf9e8370236a73cdf6a4d74dc7ab9f"><td class="memItemLeft" align="right" valign="top">uint64_t const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOTA__Update__Callback.html#a9cbf9e8370236a73cdf6a4d74dc7ab9f">Get_Timeout</a> () const</td></tr>
<tr class="memdesc:a9cbf9e8370236a73cdf6a4d74dc7ab9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the time in microseconds we wait until we declare a single chunk we attempted to download as a failure.  <a href="classOTA__Update__Callback.html#a9cbf9e8370236a73cdf6a4d74dc7ab9f">More...</a><br /></td></tr>
<tr class="separator:a9cbf9e8370236a73cdf6a4d74dc7ab9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1fdf21898c70a6eaad9ca8162aebed4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOTA__Update__Callback.html#ad1fdf21898c70a6eaad9ca8162aebed4">Set_Timeout</a> (uint64_t const &amp;timeout_microseconds)</td></tr>
<tr class="memdesc:ad1fdf21898c70a6eaad9ca8162aebed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the time in microseconds we wait until we decleare a single chunk we attempted to download as a timeout.  <a href="classOTA__Update__Callback.html#ad1fdf21898c70a6eaad9ca8162aebed4">More...</a><br /></td></tr>
<tr class="separator:ad1fdf21898c70a6eaad9ca8162aebed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classCallback"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classCallback')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classCallback.html">Callback&lt; void, bool const &amp; &gt;</a></td></tr>
<tr class="memitem:aa75102e61e75e3e3c42ab77a3f2b7b9d inherit pub_methods_classCallback"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallback.html#aa75102e61e75e3e3c42ab77a3f2b7b9d">Callback</a> ()=default</td></tr>
<tr class="memdesc:aa75102e61e75e3e3c42ab77a3f2b7b9d inherit pub_methods_classCallback"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs empty callback, will result in never being called. Internals are simply default constructed as nullptr.  <a href="classCallback.html#aa75102e61e75e3e3c42ab77a3f2b7b9d">More...</a><br /></td></tr>
<tr class="separator:aa75102e61e75e3e3c42ab77a3f2b7b9d inherit pub_methods_classCallback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3538ebd04b7d27f9a476c1c4401a18b4 inherit pub_methods_classCallback"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallback.html#a3538ebd04b7d27f9a476c1c4401a18b4">Callback</a> (<a class="el" href="classCallback.html#af45120af2b2d91741aa94c707989d9db">function</a> callback, char const *const message)</td></tr>
<tr class="memdesc:a3538ebd04b7d27f9a476c1c4401a18b4 inherit pub_methods_classCallback"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs base callback, will be called upon specific arrival of json message where the requested data was sent by the cloud and received by the client.  <a href="classCallback.html#a3538ebd04b7d27f9a476c1c4401a18b4">More...</a><br /></td></tr>
<tr class="separator:a3538ebd04b7d27f9a476c1c4401a18b4 inherit pub_methods_classCallback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f4936c591a7f35ff16bb98ff34a91aa inherit pub_methods_classCallback"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallback.html#a6f4936c591a7f35ff16bb98ff34a91aa">Call_Callback</a> (argumentTypes const &amp;... arguments) const</td></tr>
<tr class="memdesc:a6f4936c591a7f35ff16bb98ff34a91aa inherit pub_methods_classCallback"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the callback that was subscribed, when this class instance was initally created.  <a href="classCallback.html#a6f4936c591a7f35ff16bb98ff34a91aa">More...</a><br /></td></tr>
<tr class="separator:a6f4936c591a7f35ff16bb98ff34a91aa inherit pub_methods_classCallback"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e51dfc3b4e33631b2f0b6ff38bc277c inherit pub_methods_classCallback"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallback.html#a8e51dfc3b4e33631b2f0b6ff38bc277c">Set_Callback</a> (<a class="el" href="classCallback.html#af45120af2b2d91741aa94c707989d9db">function</a> callback)</td></tr>
<tr class="memdesc:a8e51dfc3b4e33631b2f0b6ff38bc277c inherit pub_methods_classCallback"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the callback method that will be called upon data arrival with the given data that was received serialized into the given argument types, used to change the callback initally passed or to set the callback if it was not passed as an argument initally.  <a href="classCallback.html#a8e51dfc3b4e33631b2f0b6ff38bc277c">More...</a><br /></td></tr>
<tr class="separator:a8e51dfc3b4e33631b2f0b6ff38bc277c inherit pub_methods_classCallback"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Over the air firmware update callback wrapper, contains the needed configuration settings to create the request that should be sent to the server. Documentation about the specific use of Over the air updates in ThingsBoard can be found here <a href="https://thingsboard.io/docs/user-guide/ota-updates/">https://thingsboard.io/docs/user-guide/ota-updates/</a>. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aaaf7a1f7a282dca68c39b5acfa750c64" name="aaaf7a1f7a282dca68c39b5acfa750c64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaf7a1f7a282dca68c39b5acfa750c64">&#9670;&#160;</a></span>progressArgumentType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classOTA__Update__Callback.html#aaaf7a1f7a282dca68c39b5acfa750c64">OTA_Update_Callback::progressArgumentType</a> =  size_t const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2c8850470eebc62db4537446dbb3b000" name="a2c8850470eebc62db4537446dbb3b000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c8850470eebc62db4537446dbb3b000">&#9670;&#160;</a></span>progressFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classOTA__Update__Callback.html#a2c8850470eebc62db4537446dbb3b000">OTA_Update_Callback::progressFn</a> =  std::function&lt;<a class="el" href="classOTA__Update__Callback.html#ae441eee469d2953b967a54883193c5aa">returnType</a>(<a class="el" href="classOTA__Update__Callback.html#aaaf7a1f7a282dca68c39b5acfa750c64">progressArgumentType</a> current, <a class="el" href="classOTA__Update__Callback.html#aaaf7a1f7a282dca68c39b5acfa750c64">progressArgumentType</a> total)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae441eee469d2953b967a54883193c5aa" name="ae441eee469d2953b967a54883193c5aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae441eee469d2953b967a54883193c5aa">&#9670;&#160;</a></span>returnType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classOTA__Update__Callback.html#ae441eee469d2953b967a54883193c5aa">OTA_Update_Callback::returnType</a> =  void</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>OTA firmware update callback signature. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3fa7b00234f950f8f529569456171dae" name="a3fa7b00234f950f8f529569456171dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa7b00234f950f8f529569456171dae">&#9670;&#160;</a></span>OTA_Update_Callback() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OTA_Update_Callback::OTA_Update_Callback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs empty callback, will result in never being called. Internals are simply default constructed as nullptr. </p>

</div>
</div>
<a id="a467931d04bd9adacd7e75d9f2452c511" name="a467931d04bd9adacd7e75d9f2452c511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a467931d04bd9adacd7e75d9f2452c511">&#9670;&#160;</a></span>OTA_Update_Callback() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OTA_Update_Callback::OTA_Update_Callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCallback.html#af45120af2b2d91741aa94c707989d9db">function</a>&#160;</td>
          <td class="paramname"><em>endCb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *const&#160;</td>
          <td class="paramname"><em>currFwTitle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *const&#160;</td>
          <td class="paramname"><em>currFwVersion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIUpdater.html">IUpdater</a> *const&#160;</td>
          <td class="paramname"><em>updater</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t const &amp;&#160;</td>
          <td class="paramname"><em>chunkRetries</em> = <code><a class="el" href="OTA__Update__Callback_8h.html#a38c3ced5cfe0c4c30998f5173fb131ed">CHUNK_RETRIES</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t const &amp;&#160;</td>
          <td class="paramname"><em>chunkSize</em> = <code><a class="el" href="OTA__Update__Callback_8h.html#aa5627c8879830b626f3cbd7ea043a22f">CHUNK_SIZE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t const &amp;&#160;</td>
          <td class="paramname"><em>timeout</em> = <code><a class="el" href="OTA__Update__Callback_8h.html#a1ec9afcfcdafeb514df4921836aac784">REQUEST_TIMEOUT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs callbacks that will be called when the OTA firmware data, has been completly sent by the cloud, received by the client and written to the flash partition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endCb</td><td>End callback method that will be called as soon as the OTA firmware update, either finished successfully or failed </td></tr>
    <tr><td class="paramname">currFwTitle</td><td>Firmware title the device has choosen, is used to only allow updates with the same given title, other updates will be canceled </td></tr>
    <tr><td class="paramname">currFwVersion</td><td>Firmware version the device is currently on, is usded to only allow updates with a different version, other updates will be canceled </td></tr>
    <tr><td class="paramname">updater</td><td>Updater implementation that writes the given firmware data </td></tr>
    <tr><td class="paramname">chunkRetries</td><td>Amount of retries the OTA firmware update has to download each seperate chunk with a given size, before the complete download is stopped and registered as failed </td></tr>
    <tr><td class="paramname">chunkSize</td><td>Size of the chunks that the firmware binary data will be split into, increased chunkSize might speed up the process by a little bit, but requires more heap memory, </td></tr>
    <tr><td class="paramname">timeout</td><td>Maximum amount of time in microseconds for the OTA firmware update for each seperate chunk, until that chunk counts as a timeout, retries is then subtraced by one and the download is retried </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa47944d3572d89af232935296d7e8857" name="aa47944d3572d89af232935296d7e8857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa47944d3572d89af232935296d7e8857">&#9670;&#160;</a></span>OTA_Update_Callback() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OTA_Update_Callback::OTA_Update_Callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOTA__Update__Callback.html#a2c8850470eebc62db4537446dbb3b000">progressFn</a>&#160;</td>
          <td class="paramname"><em>progressCb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCallback.html#af45120af2b2d91741aa94c707989d9db">function</a>&#160;</td>
          <td class="paramname"><em>endCb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *const&#160;</td>
          <td class="paramname"><em>currFwTitle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *const&#160;</td>
          <td class="paramname"><em>currFwVersion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classIUpdater.html">IUpdater</a> *const&#160;</td>
          <td class="paramname"><em>updater</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t const &amp;&#160;</td>
          <td class="paramname"><em>chunkRetries</em> = <code><a class="el" href="OTA__Update__Callback_8h.html#a38c3ced5cfe0c4c30998f5173fb131ed">CHUNK_RETRIES</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t const &amp;&#160;</td>
          <td class="paramname"><em>chunkSize</em> = <code><a class="el" href="OTA__Update__Callback_8h.html#aa5627c8879830b626f3cbd7ea043a22f">CHUNK_SIZE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t const &amp;&#160;</td>
          <td class="paramname"><em>timeout</em> = <code><a class="el" href="OTA__Update__Callback_8h.html#a1ec9afcfcdafeb514df4921836aac784">REQUEST_TIMEOUT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs callbacks that will be called when the OTA firmware data, has been completly sent by the cloud, received by the client and written to the flash partition as well as callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">progressCb</td><td>Progress callback method that will be called every time our current progress of downloading the complete firmware data changed, this makes it possible to display a progress bar or signal easily how far we are in the current downloading process </td></tr>
    <tr><td class="paramname">endCb</td><td>End callback method that will be called as soon as the OTA firmware update, either finished successfully or failed </td></tr>
    <tr><td class="paramname">currFwTitle</td><td>Firmware title the device has choosen, is used to only allow updates with the same given title, other updates will be canceled </td></tr>
    <tr><td class="paramname">currFwVersion</td><td>Firmware version the device is currently on, is usded to only allow updates with a different version, other updates will be canceled </td></tr>
    <tr><td class="paramname">updater</td><td>Updater implementation that writes the given firmware data </td></tr>
    <tr><td class="paramname">chunkRetries</td><td>Amount of retries the OTA firmware update has to download each seperate chunk with a given size, before the complete download is stopped and registered as failed </td></tr>
    <tr><td class="paramname">chunkSize</td><td>Size of the chunks that the firmware binary data will be split into, increased chunkSize might speed up the process by a little bit, but requires more heap memory, </td></tr>
    <tr><td class="paramname">timeout</td><td>Maximum amount of time in microseconds for the OTA firmware update for each seperate chunk, until that chunk counts as a timeout, retries is then subtraced by one and the download is retried </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a231b484988f8d9cbf05f8da93fdd2f76" name="a231b484988f8d9cbf05f8da93fdd2f76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a231b484988f8d9cbf05f8da93fdd2f76">&#9670;&#160;</a></span>Call_Progress_Callback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Logger &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOTA__Update__Callback.html#ae441eee469d2953b967a54883193c5aa">returnType</a> OTA_Update_Callback::Call_Progress_Callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOTA__Update__Callback.html#aaaf7a1f7a282dca68c39b5acfa750c64">progressArgumentType</a>&#160;</td>
          <td class="paramname"><em>current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOTA__Update__Callback.html#aaaf7a1f7a282dca68c39b5acfa750c64">progressArgumentType</a>&#160;</td>
          <td class="paramname"><em>total</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls the progress callback that was subscribed, when this class instance was initally created. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Logger</td><td>Implementation that should be used to print error messages generated by internal processes and additional debugging messages if THINGSBOARD_ENABLE_DEBUG is set </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current</td><td>Already received and processs amount of chunks </td></tr>
    <tr><td class="paramname">total</td><td>Total amount of chunks we need to receive and process until the update has completed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c93286b00bdb5a08ef6e11a861495c0" name="a3c93286b00bdb5a08ef6e11a861495c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c93286b00bdb5a08ef6e11a861495c0">&#9670;&#160;</a></span>Get_Chunk_Retries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t const  &amp; OTA_Update_Callback::Get_Chunk_Retries </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the amount of times we attempt to download each chunk of the OTA firmware binary file, if the download fails because it times out, doesn't let itself write into flash memory, ... the retries are decreased by 1 until we hit 0, if that is the case then we instead stop the OTA firmware update completely. </p>
<dl class="section return"><dt>Returns</dt><dd>Amount of retries for each single chunk before we abort the update </dd></dl>

</div>
</div>
<a id="a29d0cb2ac659c673cf6a063c041d3221" name="a29d0cb2ac659c673cf6a063c041d3221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d0cb2ac659c673cf6a063c041d3221">&#9670;&#160;</a></span>Get_Chunk_Size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t const  &amp; OTA_Update_Callback::Get_Chunk_Size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the size of the chunks that the firmware binary data will be split into, increased chunkSize might speed up the process by a little bit, but requires more heap memory,. </p>
<dl class="section return"><dt>Returns</dt><dd>Size of each single chunk to be downloaded </dd></dl>

</div>
</div>
<a id="af89711fdf8ea13750f8e7e4de4ca06af" name="af89711fdf8ea13750f8e7e4de4ca06af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af89711fdf8ea13750f8e7e4de4ca06af">&#9670;&#160;</a></span>Get_Firmware_Title()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char const  * OTA_Update_Callback::Get_Firmware_Title </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current firmware title, used to decide if an OTA firmware update is already installed and therefore should not be downladed, this is only done if the title of the update and the current firmware title are the same because if they are not then this firmware is meant for another device type. </p>
<dl class="section return"><dt>Returns</dt><dd>Current firmware title of the device </dd></dl>

</div>
</div>
<a id="acc5ec36b5f1c86619f224bf3b027b2f7" name="acc5ec36b5f1c86619f224bf3b027b2f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc5ec36b5f1c86619f224bf3b027b2f7">&#9670;&#160;</a></span>Get_Firmware_Version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char const  * OTA_Update_Callback::Get_Firmware_Version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current firmware version, used to decide if an OTA firmware update is already installed and therefore should not be downladed, this is only done if the version of the update and the current firmware version are different, because if they are not then we would download the same firmware as is already on the device. </p>
<dl class="section return"><dt>Returns</dt><dd>Current firmware version of the device </dd></dl>

</div>
</div>
<a id="a9cbf9e8370236a73cdf6a4d74dc7ab9f" name="a9cbf9e8370236a73cdf6a4d74dc7ab9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cbf9e8370236a73cdf6a4d74dc7ab9f">&#9670;&#160;</a></span>Get_Timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t const  &amp; OTA_Update_Callback::Get_Timeout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the time in microseconds we wait until we declare a single chunk we attempted to download as a failure. </p>
<dl class="section return"><dt>Returns</dt><dd>Timeout time until we expect a response from the server </dd></dl>

</div>
</div>
<a id="a641a07bad07a09e1159c69b927de1d31" name="a641a07bad07a09e1159c69b927de1d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a641a07bad07a09e1159c69b927de1d31">&#9670;&#160;</a></span>Get_Updater()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIUpdater.html">IUpdater</a> * OTA_Update_Callback::Get_Updater </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the updater implementation, used to write the actual firmware data into the needed memory location, so it can be used to reboot the given device with that new flashed firmware. </p>
<dl class="section return"><dt>Returns</dt><dd>Updater implementation that writes the given firmware data </dd></dl>

</div>
</div>
<a id="a4db00c12808ebfdfbd2abebbfe74ce07" name="a4db00c12808ebfdfbd2abebbfe74ce07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4db00c12808ebfdfbd2abebbfe74ce07">&#9670;&#160;</a></span>Set_Chunk_Retries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OTA_Update_Callback::Set_Chunk_Retries </td>
          <td>(</td>
          <td class="paramtype">uint8_t const &amp;&#160;</td>
          <td class="paramname"><em>chunkRetries</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the amount of times we attempt to download each chunk of the OTA firmware binary file, if the download fails because it times out, doesn't let itself write into flash memory, ... the retries are decreased by 1 until we hit 0, if that is the case then we instead stop the OTA firmware update completely. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chunkRetries</td><td>Amount of retries for each single chunk before we abort the update </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a185d04638cc0a4c6a2c30694b73d4bc2" name="a185d04638cc0a4c6a2c30694b73d4bc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a185d04638cc0a4c6a2c30694b73d4bc2">&#9670;&#160;</a></span>Set_Chunk_Size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OTA_Update_Callback::Set_Chunk_Size </td>
          <td>(</td>
          <td class="paramtype">uint16_t const &amp;&#160;</td>
          <td class="paramname"><em>chunkSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the size of the chunks that the firmware binary data will be split into, increased chunkSize might speed up the process by a little bit, but requires more heap memory,. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chunkSize</td><td>Size of each single chunk to be downloaded </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1bb9c850716c581f6325bb7ec113aef" name="ab1bb9c850716c581f6325bb7ec113aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1bb9c850716c581f6325bb7ec113aef">&#9670;&#160;</a></span>Set_Firmware_Title()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OTA_Update_Callback::Set_Firmware_Title </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>currFwTitle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the current firmware title, used to decide if an OTA firmware update is already installed and therefore should not be downladed, this is only done if the title of the update and the current firmware title are the same because if they are not then this firmware is meant for another device type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currFwTitle</td><td>Current firmware title of the device </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a95942a7ce63e55e610b2f650b8cf9a" name="a7a95942a7ce63e55e610b2f650b8cf9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a95942a7ce63e55e610b2f650b8cf9a">&#9670;&#160;</a></span>Set_Firmware_Version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OTA_Update_Callback::Set_Firmware_Version </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>currFwVersion</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the current firmware version, used to decide if an OTA firmware update is already installed and therefore should not be downladed, this is only done if the version of the update and the current firmware version are different, because if they are not then we would download the same firmware as is already on the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currFwVersion</td><td>Current firmware version of the device </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aefff7f533e630fd4b1491a96043d9858" name="aefff7f533e630fd4b1491a96043d9858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefff7f533e630fd4b1491a96043d9858">&#9670;&#160;</a></span>Set_Progress_Callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OTA_Update_Callback::Set_Progress_Callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOTA__Update__Callback.html#a2c8850470eebc62db4537446dbb3b000">progressFn</a>&#160;</td>
          <td class="paramname"><em>progressCb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the progress callback method that will be called every time our current progress of downloading the complete firmware data changed, this makes it possible to display a progress bar or signal easily how far we are in the current downloading process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">progressCb</td><td>Progress callback method that will be called </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1fdf21898c70a6eaad9ca8162aebed4" name="ad1fdf21898c70a6eaad9ca8162aebed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1fdf21898c70a6eaad9ca8162aebed4">&#9670;&#160;</a></span>Set_Timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OTA_Update_Callback::Set_Timeout </td>
          <td>(</td>
          <td class="paramtype">uint64_t const &amp;&#160;</td>
          <td class="paramname"><em>timeout_microseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the time in microseconds we wait until we decleare a single chunk we attempted to download as a timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_microseconds</td><td>Timeout time until we expect a response from the server </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68f6f6c5dba7c3587c1e255f85e8dd67" name="a68f6f6c5dba7c3587c1e255f85e8dd67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68f6f6c5dba7c3587c1e255f85e8dd67">&#9670;&#160;</a></span>Set_Updater()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OTA_Update_Callback::Set_Updater </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIUpdater.html">IUpdater</a> *&#160;</td>
          <td class="paramname"><em>updater</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the updater implementation, used to write the actual firmware data into the needed memory location, so it can be used to reboot the given device with that new flashed firmware. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">updater</td><td>Updater implementation that writes the given firmware data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="OTA__Update__Callback_8h_source.html">OTA_Update_Callback.h</a></li>
<li>src/<a class="el" href="OTA__Update__Callback_8cpp.html">OTA_Update_Callback.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
