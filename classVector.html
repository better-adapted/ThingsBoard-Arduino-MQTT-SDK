<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ThingsBoard Client SDK: Vector&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">ThingsBoard Client SDK<span id="projectnumber">&#160;0.13.0</span>
   </div>
   <div id="projectbrief">Client SDK to connect with ThingsBoard IoT Platform from IoT devices (Arduino, Espressif, etc.)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classVector-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Vector&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Replacement data container for boards that do not support the C++ STL and therefore do not have the std::vector class.  
 <a href="classVector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Vector_8h_source.html">Vector.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abd883e8ec6e3452f1e36484c9844048d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#abd883e8ec6e3452f1e36484c9844048d">Vector</a> (void)</td></tr>
<tr class="memdesc:abd883e8ec6e3452f1e36484c9844048d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classVector.html#abd883e8ec6e3452f1e36484c9844048d">More...</a><br /></td></tr>
<tr class="separator:abd883e8ec6e3452f1e36484c9844048d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6138128eb8c9828944fcd10ec2cb89e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a6138128eb8c9828944fcd10ec2cb89e0">Vector</a> (T const *const first, T const *const last)</td></tr>
<tr class="memdesc:a6138128eb8c9828944fcd10ec2cb89e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that allows compatibility with std::vector, simply forwards call to internal insert method.  <a href="classVector.html#a6138128eb8c9828944fcd10ec2cb89e0">More...</a><br /></td></tr>
<tr class="separator:a6138128eb8c9828944fcd10ec2cb89e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd524fac19e6d3d69db5198ffe2952b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#afd524fac19e6d3d69db5198ffe2952b0">~Vector</a> ()</td></tr>
<tr class="memdesc:afd524fac19e6d3d69db5198ffe2952b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classVector.html#afd524fac19e6d3d69db5198ffe2952b0">More...</a><br /></td></tr>
<tr class="separator:afd524fac19e6d3d69db5198ffe2952b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee189706c0c29b1296aabfe5a0cb04dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#aee189706c0c29b1296aabfe5a0cb04dc">assign</a> (T const *const first, T const *const last)</td></tr>
<tr class="memdesc:aee189706c0c29b1296aabfe5a0cb04dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method that allows compatibility with std::vector, simply forwards call to internal insert method.  <a href="classVector.html#aee189706c0c29b1296aabfe5a0cb04dc">More...</a><br /></td></tr>
<tr class="separator:aee189706c0c29b1296aabfe5a0cb04dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad688a8a0dfbd07ea63d838058a436f79"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#ad688a8a0dfbd07ea63d838058a436f79">empty</a> () const</td></tr>
<tr class="memdesc:ad688a8a0dfbd07ea63d838058a436f79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether there are still any element in the underlying data container.  <a href="classVector.html#ad688a8a0dfbd07ea63d838058a436f79">More...</a><br /></td></tr>
<tr class="separator:ad688a8a0dfbd07ea63d838058a436f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61ced7fc3c537b27b46d2e70cde8bae"><td class="memItemLeft" align="right" valign="top">size_t const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#ab61ced7fc3c537b27b46d2e70cde8bae">size</a> () const</td></tr>
<tr class="memdesc:ab61ced7fc3c537b27b46d2e70cde8bae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current amount of elements in the underlying data container.  <a href="classVector.html#ab61ced7fc3c537b27b46d2e70cde8bae">More...</a><br /></td></tr>
<tr class="separator:ab61ced7fc3c537b27b46d2e70cde8bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a337a38f68a47443fe43f6e62a92e07c5"><td class="memItemLeft" align="right" valign="top">size_t const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a337a38f68a47443fe43f6e62a92e07c5">capacity</a> () const</td></tr>
<tr class="memdesc:a337a38f68a47443fe43f6e62a92e07c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum amount of elements that can currently be stored in the underlying data container.  <a href="classVector.html#a337a38f68a47443fe43f6e62a92e07c5">More...</a><br /></td></tr>
<tr class="separator:a337a38f68a47443fe43f6e62a92e07c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48330adb902d17d3fbed6e83fd58976f"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a48330adb902d17d3fbed6e83fd58976f">begin</a> ()</td></tr>
<tr class="memdesc:a48330adb902d17d3fbed6e83fd58976f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the first element of the vector.  <a href="classVector.html#a48330adb902d17d3fbed6e83fd58976f">More...</a><br /></td></tr>
<tr class="separator:a48330adb902d17d3fbed6e83fd58976f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e4b824d5ce3f1335064e8e5ad7986e"><td class="memItemLeft" align="right" valign="top">T const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#ad0e4b824d5ce3f1335064e8e5ad7986e">begin</a> () const</td></tr>
<tr class="memdesc:ad0e4b824d5ce3f1335064e8e5ad7986e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant pointer to the first element of the vector.  <a href="classVector.html#ad0e4b824d5ce3f1335064e8e5ad7986e">More...</a><br /></td></tr>
<tr class="separator:ad0e4b824d5ce3f1335064e8e5ad7986e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038dc511af85f21071eee4fbb0e2157b"><td class="memItemLeft" align="right" valign="top">T const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a038dc511af85f21071eee4fbb0e2157b">cbegin</a> () const</td></tr>
<tr class="memdesc:a038dc511af85f21071eee4fbb0e2157b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant pointer to the first element of the vector.  <a href="classVector.html#a038dc511af85f21071eee4fbb0e2157b">More...</a><br /></td></tr>
<tr class="separator:a038dc511af85f21071eee4fbb0e2157b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6decf0bdeb6849bfcc151b2c514f639f"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a6decf0bdeb6849bfcc151b2c514f639f">back</a> ()</td></tr>
<tr class="memdesc:a6decf0bdeb6849bfcc151b2c514f639f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last element of the vector.  <a href="classVector.html#a6decf0bdeb6849bfcc151b2c514f639f">More...</a><br /></td></tr>
<tr class="separator:a6decf0bdeb6849bfcc151b2c514f639f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8958aac9b8931d471cdd99428c2d535"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#aa8958aac9b8931d471cdd99428c2d535">end</a> ()</td></tr>
<tr class="memdesc:aa8958aac9b8931d471cdd99428c2d535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to one-past-the-end element of the vector.  <a href="classVector.html#aa8958aac9b8931d471cdd99428c2d535">More...</a><br /></td></tr>
<tr class="separator:aa8958aac9b8931d471cdd99428c2d535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d157a237936c342152bb80c26c9712"><td class="memItemLeft" align="right" valign="top">T const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a08d157a237936c342152bb80c26c9712">end</a> () const</td></tr>
<tr class="memdesc:a08d157a237936c342152bb80c26c9712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant pointer to one-past-the-end element of the vector.  <a href="classVector.html#a08d157a237936c342152bb80c26c9712">More...</a><br /></td></tr>
<tr class="separator:a08d157a237936c342152bb80c26c9712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78be46ba3119316b48f7673d3d164c7d"><td class="memItemLeft" align="right" valign="top">T const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a78be46ba3119316b48f7673d3d164c7d">cend</a> () const</td></tr>
<tr class="memdesc:a78be46ba3119316b48f7673d3d164c7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant pointer to one-past-the-end element of the vector.  <a href="classVector.html#a78be46ba3119316b48f7673d3d164c7d">More...</a><br /></td></tr>
<tr class="separator:a78be46ba3119316b48f7673d3d164c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78b9bdb8d670f1a00ddfa9a1a4c059f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#ab78b9bdb8d670f1a00ddfa9a1a4c059f">push_back</a> (T const &amp;element)</td></tr>
<tr class="memdesc:ab78b9bdb8d670f1a00ddfa9a1a4c059f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given element at the end of the underlying data container. Increases the size of the underlying data container if it is already full and has no remaining space for new elements. The growth is exponential meaning it doubles every time the underlying data container has to be increased. This results in an amortized insertion speed of O(1), but might require 0(n) when the container has to be reallocated to be increased.  <a href="classVector.html#ab78b9bdb8d670f1a00ddfa9a1a4c059f">More...</a><br /></td></tr>
<tr class="separator:ab78b9bdb8d670f1a00ddfa9a1a4c059f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a53d0e44a8cddeec3d1e8cf8dda971"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a91a53d0e44a8cddeec3d1e8cf8dda971">insert</a> (T const *const position, T const *first, T const *const last)</td></tr>
<tr class="memdesc:a91a53d0e44a8cddeec3d1e8cf8dda971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts all element from the given start to the given end iterator into the underlying data container. Simply calls push_back on each element.  <a href="classVector.html#a91a53d0e44a8cddeec3d1e8cf8dda971">More...</a><br /></td></tr>
<tr class="separator:a91a53d0e44a8cddeec3d1e8cf8dda971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a518d65cc9359e148b548abb3eb6104d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a518d65cc9359e148b548abb3eb6104d4">erase</a> (T const *const iterator)</td></tr>
<tr class="memdesc:a518d65cc9359e148b548abb3eb6104d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element at the given iterator, has to move all element one to the left if the index is not at the end of the array.  <a href="classVector.html#a518d65cc9359e148b548abb3eb6104d4">More...</a><br /></td></tr>
<tr class="separator:a518d65cc9359e148b548abb3eb6104d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7afc8b55341c819e697257681342cb79"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a7afc8b55341c819e697257681342cb79">at</a> (size_t const &amp;index)</td></tr>
<tr class="memdesc:a7afc8b55341c819e697257681342cb79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to access an element at a given index, ensures the device crashes if we attempted to access in an invalid location.  <a href="classVector.html#a7afc8b55341c819e697257681342cb79">More...</a><br /></td></tr>
<tr class="separator:a7afc8b55341c819e697257681342cb79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eaadbf45c7ea7dcc90bfc89b89335a6"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a3eaadbf45c7ea7dcc90bfc89b89335a6">operator[]</a> (size_t const &amp;index)</td></tr>
<tr class="memdesc:a3eaadbf45c7ea7dcc90bfc89b89335a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bracket operator to access an element at a given index. Does not do any bounds checks, meaning the access is more efficient but it is possible to read out of bounds data.  <a href="classVector.html#a3eaadbf45c7ea7dcc90bfc89b89335a6">More...</a><br /></td></tr>
<tr class="separator:a3eaadbf45c7ea7dcc90bfc89b89335a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01408bf78f5b72ea416b4c1d2e108ddb"><td class="memItemLeft" align="right" valign="top">T const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a01408bf78f5b72ea416b4c1d2e108ddb">operator[]</a> (size_t const &amp;index) const</td></tr>
<tr class="memdesc:a01408bf78f5b72ea416b4c1d2e108ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bracket operator to access an element at a given index. Does not do any bounds checks, meaning the access is more efficient but it is possible to read out of bounds data.  <a href="classVector.html#a01408bf78f5b72ea416b4c1d2e108ddb">More...</a><br /></td></tr>
<tr class="separator:a01408bf78f5b72ea416b4c1d2e108ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ad98b135472b0ebc5d6cb3ae5d0085"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVector.html#a32ad98b135472b0ebc5d6cb3ae5d0085">clear</a> ()</td></tr>
<tr class="memdesc:a32ad98b135472b0ebc5d6cb3ae5d0085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the given underlying data container. Simply sets the underlying size to 0, data will only be cleared in the destructor.  <a href="classVector.html#a32ad98b135472b0ebc5d6cb3ae5d0085">More...</a><br /></td></tr>
<tr class="separator:a32ad98b135472b0ebc5d6cb3ae5d0085"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T&gt;<br />
class Vector&lt; T &gt;</div><p >Replacement data container for boards that do not support the C++ STL and therefore do not have the std::vector class. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the underlying data the list should point too. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abd883e8ec6e3452f1e36484c9844048d" name="abd883e8ec6e3452f1e36484c9844048d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd883e8ec6e3452f1e36484c9844048d">&#9670;&#160;</a></span>Vector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; T &gt;<a class="el" href="classVector.html">::Vector</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>

</div>
</div>
<a id="a6138128eb8c9828944fcd10ec2cb89e0" name="a6138128eb8c9828944fcd10ec2cb89e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6138128eb8c9828944fcd10ec2cb89e0">&#9670;&#160;</a></span>Vector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; T &gt;<a class="el" href="classVector.html">::Vector</a> </td>
          <td>(</td>
          <td class="paramtype">T const *const&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const *const&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor that allows compatibility with std::vector, simply forwards call to internal insert method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Beginning of the elements we want to copy into our underlying data container </td></tr>
    <tr><td class="paramname">last</td><td>One past the end of the elements we want to copy into our underlying data container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd524fac19e6d3d69db5198ffe2952b0" name="afd524fac19e6d3d69db5198ffe2952b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd524fac19e6d3d69db5198ffe2952b0">&#9670;&#160;</a></span>~Vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; T &gt;::~<a class="el" href="classVector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aee189706c0c29b1296aabfe5a0cb04dc" name="aee189706c0c29b1296aabfe5a0cb04dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee189706c0c29b1296aabfe5a0cb04dc">&#9670;&#160;</a></span>assign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; T &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">T const *const&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const *const&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method that allows compatibility with std::vector, simply forwards call to internal insert method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Beginning of the elements we want to copy into our underlying data container </td></tr>
    <tr><td class="paramname">last</td><td>One past the end of the elements we want to copy into our underlying data container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7afc8b55341c819e697257681342cb79" name="a7afc8b55341c819e697257681342cb79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7afc8b55341c819e697257681342cb79">&#9670;&#160;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classVector.html">Vector</a>&lt; T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_t const &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method to access an element at a given index, ensures the device crashes if we attempted to access in an invalid location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index we want to get the corresponding element for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6decf0bdeb6849bfcc151b2c514f639f" name="a6decf0bdeb6849bfcc151b2c514f639f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6decf0bdeb6849bfcc151b2c514f639f">&#9670;&#160;</a></span>back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classVector.html">Vector</a>&lt; T &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the last element of the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the last element of the vector </dd></dl>

</div>
</div>
<a id="a48330adb902d17d3fbed6e83fd58976f" name="a48330adb902d17d3fbed6e83fd58976f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48330adb902d17d3fbed6e83fd58976f">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="classVector.html">Vector</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the first element of the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the first element of the vector </dd></dl>

</div>
</div>
<a id="ad0e4b824d5ce3f1335064e8e5ad7986e" name="ad0e4b824d5ce3f1335064e8e5ad7986e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0e4b824d5ce3f1335064e8e5ad7986e">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T const  * <a class="el" href="classVector.html">Vector</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant pointer to the first element of the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Constant pointer to the first element of the vector </dd></dl>

</div>
</div>
<a id="a337a38f68a47443fe43f6e62a92e07c5" name="a337a38f68a47443fe43f6e62a92e07c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a337a38f68a47443fe43f6e62a92e07c5">&#9670;&#160;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t const  &amp; <a class="el" href="classVector.html">Vector</a>&lt; T &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum amount of elements that can currently be stored in the underlying data container. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum amount of items that can currently be stored in the underlying data container </dd></dl>

</div>
</div>
<a id="a038dc511af85f21071eee4fbb0e2157b" name="a038dc511af85f21071eee4fbb0e2157b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a038dc511af85f21071eee4fbb0e2157b">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T const  * <a class="el" href="classVector.html">Vector</a>&lt; T &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant pointer to the first element of the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Constant pointer to the first element of the vector </dd></dl>

</div>
</div>
<a id="a78be46ba3119316b48f7673d3d164c7d" name="a78be46ba3119316b48f7673d3d164c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78be46ba3119316b48f7673d3d164c7d">&#9670;&#160;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T const  * <a class="el" href="classVector.html">Vector</a>&lt; T &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant pointer to one-past-the-end element of the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Constant pointer to one-past-the-end element of the vector </dd></dl>

</div>
</div>
<a id="a32ad98b135472b0ebc5d6cb3ae5d0085" name="a32ad98b135472b0ebc5d6cb3ae5d0085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32ad98b135472b0ebc5d6cb3ae5d0085">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; T &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the given underlying data container. Simply sets the underlying size to 0, data will only be cleared in the destructor. </p>

</div>
</div>
<a id="ad688a8a0dfbd07ea63d838058a436f79" name="ad688a8a0dfbd07ea63d838058a436f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad688a8a0dfbd07ea63d838058a436f79">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVector.html">Vector</a>&lt; T &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether there are still any element in the underlying data container. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether the underlying data container is empty or not </dd></dl>

</div>
</div>
<a id="aa8958aac9b8931d471cdd99428c2d535" name="aa8958aac9b8931d471cdd99428c2d535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8958aac9b8931d471cdd99428c2d535">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="classVector.html">Vector</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to one-past-the-end element of the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to one-past-the-end element of the vector </dd></dl>

</div>
</div>
<a id="a08d157a237936c342152bb80c26c9712" name="a08d157a237936c342152bb80c26c9712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08d157a237936c342152bb80c26c9712">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T const  * <a class="el" href="classVector.html">Vector</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant pointer to one-past-the-end element of the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Constant pointer to one-past-the-end element of the vector </dd></dl>

</div>
</div>
<a id="a518d65cc9359e148b548abb3eb6104d4" name="a518d65cc9359e148b548abb3eb6104d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a518d65cc9359e148b548abb3eb6104d4">&#9670;&#160;</a></span>erase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; T &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">T const *const&#160;</td>
          <td class="paramname"><em>iterator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the element at the given iterator, has to move all element one to the left if the index is not at the end of the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterator</td><td>Iterator the element should be removed at from the underlying data container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91a53d0e44a8cddeec3d1e8cf8dda971" name="a91a53d0e44a8cddeec3d1e8cf8dda971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a53d0e44a8cddeec3d1e8cf8dda971">&#9670;&#160;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">T const *const&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const *const&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts all element from the given start to the given end iterator into the underlying data container. Simply calls push_back on each element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Attribute is not used and can be left as nullptr, simply there to keep compatibility with std::vector insert method </td></tr>
    <tr><td class="paramname">first</td><td>Beginning of the elements we want to copy into our underlying data container </td></tr>
    <tr><td class="paramname">last</td><td>One past the end of the elements we want to copy into our underlying data container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3eaadbf45c7ea7dcc90bfc89b89335a6" name="a3eaadbf45c7ea7dcc90bfc89b89335a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eaadbf45c7ea7dcc90bfc89b89335a6">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classVector.html">Vector</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t const &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bracket operator to access an element at a given index. Does not do any bounds checks, meaning the access is more efficient but it is possible to read out of bounds data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index we want to get the corresponding element for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01408bf78f5b72ea416b4c1d2e108ddb" name="a01408bf78f5b72ea416b4c1d2e108ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01408bf78f5b72ea416b4c1d2e108ddb">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T const  &amp; <a class="el" href="classVector.html">Vector</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t const &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bracket operator to access an element at a given index. Does not do any bounds checks, meaning the access is more efficient but it is possible to read out of bounds data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index we want to get the corresponding element for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab78b9bdb8d670f1a00ddfa9a1a4c059f" name="ab78b9bdb8d670f1a00ddfa9a1a4c059f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab78b9bdb8d670f1a00ddfa9a1a4c059f">&#9670;&#160;</a></span>push_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVector.html">Vector</a>&lt; T &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the given element at the end of the underlying data container. Increases the size of the underlying data container if it is already full and has no remaining space for new elements. The growth is exponential meaning it doubles every time the underlying data container has to be increased. This results in an amortized insertion speed of O(1), but might require 0(n) when the container has to be reallocated to be increased. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>Element that should be inserted at the end </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab61ced7fc3c537b27b46d2e70cde8bae" name="ab61ced7fc3c537b27b46d2e70cde8bae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab61ced7fc3c537b27b46d2e70cde8bae">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t const  &amp; <a class="el" href="classVector.html">Vector</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the current amount of elements in the underlying data container. </p>
<dl class="section return"><dt>Returns</dt><dd>The amount of items currently in the underlying data container </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="Vector_8h_source.html">Vector.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
