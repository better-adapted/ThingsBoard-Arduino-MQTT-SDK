<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ThingsBoard Client SDK: Array&lt; T, Capacity &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">ThingsBoard Client SDK<span id="projectnumber">&#160;0.13.0</span>
   </div>
   <div id="projectbrief">Client SDK to connect with ThingsBoard IoT Platform from IoT devices (Arduino, Espressif, etc.)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classArray-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Array&lt; T, Capacity &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Replacement data container for boards that do not support the C++ STL and therefore do not have the std::array class.  
 <a href="classArray.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Array_8h_source.html">Array.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a43a8bd1b34a623427eb5c0b0afa6d91c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArray.html#a43a8bd1b34a623427eb5c0b0afa6d91c">Array</a> (void)=default</td></tr>
<tr class="memdesc:a43a8bd1b34a623427eb5c0b0afa6d91c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classArray.html#a43a8bd1b34a623427eb5c0b0afa6d91c">More...</a><br /></td></tr>
<tr class="separator:a43a8bd1b34a623427eb5c0b0afa6d91c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c8f246c3f923cf5a1f845a378201d9e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArray.html#a0c8f246c3f923cf5a1f845a378201d9e">Array</a> (T const *const first, T const *const last)</td></tr>
<tr class="memdesc:a0c8f246c3f923cf5a1f845a378201d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that allows compatibility with std::vector, simply forwards call to internal insert method.  <a href="classArray.html#a0c8f246c3f923cf5a1f845a378201d9e">More...</a><br /></td></tr>
<tr class="separator:a0c8f246c3f923cf5a1f845a378201d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa671a299d98190f267443bc95bc8ab3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArray.html#aa671a299d98190f267443bc95bc8ab3e">assign</a> (T const *const first, T const *const last)</td></tr>
<tr class="memdesc:aa671a299d98190f267443bc95bc8ab3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method that allows compatibility with std::vector, simply forwards call to internal insert method.  <a href="classArray.html#aa671a299d98190f267443bc95bc8ab3e">More...</a><br /></td></tr>
<tr class="separator:aa671a299d98190f267443bc95bc8ab3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b56c91a89d22a430223dd43664b7def"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArray.html#a8b56c91a89d22a430223dd43664b7def">empty</a> () const</td></tr>
<tr class="memdesc:a8b56c91a89d22a430223dd43664b7def"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether there are still any element in the underlying data container.  <a href="classArray.html#a8b56c91a89d22a430223dd43664b7def">More...</a><br /></td></tr>
<tr class="separator:a8b56c91a89d22a430223dd43664b7def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9239d4fc1d30daeb07b6f2b5844fa97"><td class="memItemLeft" align="right" valign="top">size_t const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArray.html#aa9239d4fc1d30daeb07b6f2b5844fa97">size</a> () const</td></tr>
<tr class="memdesc:aa9239d4fc1d30daeb07b6f2b5844fa97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current amount of elements in the underlying data container.  <a href="classArray.html#aa9239d4fc1d30daeb07b6f2b5844fa97">More...</a><br /></td></tr>
<tr class="separator:aa9239d4fc1d30daeb07b6f2b5844fa97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7de134b93dbec27244349cdd10fd40"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArray.html#a8f7de134b93dbec27244349cdd10fd40">capacity</a> () const</td></tr>
<tr class="memdesc:a8f7de134b93dbec27244349cdd10fd40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum amount of elements that can currently be stored in the underlying data container.  <a href="classArray.html#a8f7de134b93dbec27244349cdd10fd40">More...</a><br /></td></tr>
<tr class="separator:a8f7de134b93dbec27244349cdd10fd40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba298d705a7b1b98c237c7e077079c6"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArray.html#acba298d705a7b1b98c237c7e077079c6">begin</a> ()</td></tr>
<tr class="memdesc:acba298d705a7b1b98c237c7e077079c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant pointer to the first element of the vector.  <a href="classArray.html#acba298d705a7b1b98c237c7e077079c6">More...</a><br /></td></tr>
<tr class="separator:acba298d705a7b1b98c237c7e077079c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649850b709a4192a55176a58aa5a0e50"><td class="memItemLeft" align="right" valign="top">T const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArray.html#a649850b709a4192a55176a58aa5a0e50">begin</a> () const</td></tr>
<tr class="memdesc:a649850b709a4192a55176a58aa5a0e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant pointer to the first element of the vector.  <a href="classArray.html#a649850b709a4192a55176a58aa5a0e50">More...</a><br /></td></tr>
<tr class="separator:a649850b709a4192a55176a58aa5a0e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb279b27f54a2530575b51da33a15e0a"><td class="memItemLeft" align="right" valign="top">T const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArray.html#aeb279b27f54a2530575b51da33a15e0a">cbegin</a> () const</td></tr>
<tr class="memdesc:aeb279b27f54a2530575b51da33a15e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant pointer to the first element of the vector.  <a href="classArray.html#aeb279b27f54a2530575b51da33a15e0a">More...</a><br /></td></tr>
<tr class="separator:aeb279b27f54a2530575b51da33a15e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09326a0aea557d080f856d2d02734a54"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArray.html#a09326a0aea557d080f856d2d02734a54">back</a> ()</td></tr>
<tr class="memdesc:a09326a0aea557d080f856d2d02734a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last element of the vector.  <a href="classArray.html#a09326a0aea557d080f856d2d02734a54">More...</a><br /></td></tr>
<tr class="separator:a09326a0aea557d080f856d2d02734a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0422f0975fa4bd276ef88866ec6ca1d"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArray.html#ae0422f0975fa4bd276ef88866ec6ca1d">end</a> ()</td></tr>
<tr class="memdesc:ae0422f0975fa4bd276ef88866ec6ca1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to one-past-the-end element of the vector.  <a href="classArray.html#ae0422f0975fa4bd276ef88866ec6ca1d">More...</a><br /></td></tr>
<tr class="separator:ae0422f0975fa4bd276ef88866ec6ca1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a233404f5a66c7c2d434f60911bdccdd8"><td class="memItemLeft" align="right" valign="top">T const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArray.html#a233404f5a66c7c2d434f60911bdccdd8">end</a> () const</td></tr>
<tr class="memdesc:a233404f5a66c7c2d434f60911bdccdd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant pointer to one-past-the-end element of the vector.  <a href="classArray.html#a233404f5a66c7c2d434f60911bdccdd8">More...</a><br /></td></tr>
<tr class="separator:a233404f5a66c7c2d434f60911bdccdd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416f0777cffcd9cede627aaff0bbe6bb"><td class="memItemLeft" align="right" valign="top">T const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArray.html#a416f0777cffcd9cede627aaff0bbe6bb">cend</a> () const</td></tr>
<tr class="memdesc:a416f0777cffcd9cede627aaff0bbe6bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant pointer to one-past-the-end element of the vector.  <a href="classArray.html#a416f0777cffcd9cede627aaff0bbe6bb">More...</a><br /></td></tr>
<tr class="separator:a416f0777cffcd9cede627aaff0bbe6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f8a222828c457b826642c8faa7d8feb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArray.html#a7f8a222828c457b826642c8faa7d8feb">push_back</a> (T const &amp;element)</td></tr>
<tr class="memdesc:a7f8a222828c457b826642c8faa7d8feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given element at the end of the underlying data container, If the interal data structure is full already then this method will assert and stop the application. Because if we do not we could cause an out of bounds write, which could possibly overwrite other memory. Causing hard to debug issues, therefore this behaviour is not allowed in the first place.  <a href="classArray.html#a7f8a222828c457b826642c8faa7d8feb">More...</a><br /></td></tr>
<tr class="separator:a7f8a222828c457b826642c8faa7d8feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18f86feafd7b88f40dd631655716c13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArray.html#ac18f86feafd7b88f40dd631655716c13">insert</a> (T const *const position, T const *first, T const *const last)</td></tr>
<tr class="memdesc:ac18f86feafd7b88f40dd631655716c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts all element from the given start to the given end iterator into the underlying data container. Simply calls push_back on each element, meaning if the initally allocated size if not big enough to hold all elements, then this method will simply not insert those elements instead.  <a href="classArray.html#ac18f86feafd7b88f40dd631655716c13">More...</a><br /></td></tr>
<tr class="separator:ac18f86feafd7b88f40dd631655716c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7371c9815908da4c7c44664b2be64d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArray.html#aa7371c9815908da4c7c44664b2be64d1">erase</a> (T const *const iterator)</td></tr>
<tr class="memdesc:aa7371c9815908da4c7c44664b2be64d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element at the given iterator, has to move all element one to the left if the index is not at the end of the array.  <a href="classArray.html#aa7371c9815908da4c7c44664b2be64d1">More...</a><br /></td></tr>
<tr class="separator:aa7371c9815908da4c7c44664b2be64d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81478550622ac8741a50d103c40237ac"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArray.html#a81478550622ac8741a50d103c40237ac">at</a> (size_t const &amp;index)</td></tr>
<tr class="memdesc:a81478550622ac8741a50d103c40237ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to access an element at a given index, ensures the device crashes if we attempted to access in an invalid location.  <a href="classArray.html#a81478550622ac8741a50d103c40237ac">More...</a><br /></td></tr>
<tr class="separator:a81478550622ac8741a50d103c40237ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683e5ca9ab0b009eb1880fa20e7fca1e"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArray.html#a683e5ca9ab0b009eb1880fa20e7fca1e">operator[]</a> (size_t const &amp;index)</td></tr>
<tr class="memdesc:a683e5ca9ab0b009eb1880fa20e7fca1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bracket operator to access an element at a given index. Does not do any bounds checks, meaning the access is more efficient but it is possible to read out of bounds data.  <a href="classArray.html#a683e5ca9ab0b009eb1880fa20e7fca1e">More...</a><br /></td></tr>
<tr class="separator:a683e5ca9ab0b009eb1880fa20e7fca1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c0d465703091b52d7ef1f51ab872be"><td class="memItemLeft" align="right" valign="top">T const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArray.html#aa9c0d465703091b52d7ef1f51ab872be">operator[]</a> (size_t const &amp;index) const</td></tr>
<tr class="memdesc:aa9c0d465703091b52d7ef1f51ab872be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bracket operator to access an element at a given index. Does not do any bounds checks, meaning the access is more efficient but it is possible to read out of bounds data.  <a href="classArray.html#aa9c0d465703091b52d7ef1f51ab872be">More...</a><br /></td></tr>
<tr class="separator:aa9c0d465703091b52d7ef1f51ab872be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ee8f81241ce57ee65a3d979b807f56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArray.html#a77ee8f81241ce57ee65a3d979b807f56">clear</a> ()</td></tr>
<tr class="memdesc:a77ee8f81241ce57ee65a3d979b807f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the given underlying data container. Simply sets the underlying size to 0, data will only be cleared in the destructor.  <a href="classArray.html#a77ee8f81241ce57ee65a3d979b807f56">More...</a><br /></td></tr>
<tr class="separator:a77ee8f81241ce57ee65a3d979b807f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T, size_t Capacity&gt;<br />
class Array&lt; T, Capacity &gt;</div><p >Replacement data container for boards that do not support the C++ STL and therefore do not have the std::array class. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the underlying data the list should point too. </td></tr>
    <tr><td class="paramname">Capacity</td><td>Amount of elements that can be saved into the underlying data structure allows to wrap a simple c-array and allocate it on the stack. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a43a8bd1b34a623427eb5c0b0afa6d91c" name="a43a8bd1b34a623427eb5c0b0afa6d91c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43a8bd1b34a623427eb5c0b0afa6d91c">&#9670;&#160;</a></span>Array() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArray.html">Array</a>&lt; T, Capacity &gt;<a class="el" href="classArray.html">::Array</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>

</div>
</div>
<a id="a0c8f246c3f923cf5a1f845a378201d9e" name="a0c8f246c3f923cf5a1f845a378201d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c8f246c3f923cf5a1f845a378201d9e">&#9670;&#160;</a></span>Array() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArray.html">Array</a>&lt; T, Capacity &gt;<a class="el" href="classArray.html">::Array</a> </td>
          <td>(</td>
          <td class="paramtype">T const *const&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const *const&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor that allows compatibility with std::vector, simply forwards call to internal insert method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Beginning of the elements we want to copy into our underlying data container </td></tr>
    <tr><td class="paramname">last</td><td>One past the end of the elements we want to copy into our underlying data container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa671a299d98190f267443bc95bc8ab3e" name="aa671a299d98190f267443bc95bc8ab3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa671a299d98190f267443bc95bc8ab3e">&#9670;&#160;</a></span>assign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classArray.html">Array</a>&lt; T, Capacity &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">T const *const&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const *const&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method that allows compatibility with std::vector, simply forwards call to internal insert method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Beginning of the elements we want to copy into our underlying data container </td></tr>
    <tr><td class="paramname">last</td><td>One past the end of the elements we want to copy into our underlying data container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81478550622ac8741a50d103c40237ac" name="a81478550622ac8741a50d103c40237ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81478550622ac8741a50d103c40237ac">&#9670;&#160;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classArray.html">Array</a>&lt; T, Capacity &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_t const &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method to access an element at a given index, ensures the device crashes if we attempted to access in an invalid location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index we want to get the corresponding element for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09326a0aea557d080f856d2d02734a54" name="a09326a0aea557d080f856d2d02734a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09326a0aea557d080f856d2d02734a54">&#9670;&#160;</a></span>back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classArray.html">Array</a>&lt; T, Capacity &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the last element of the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the last element of the vector </dd></dl>

</div>
</div>
<a id="acba298d705a7b1b98c237c7e077079c6" name="acba298d705a7b1b98c237c7e077079c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acba298d705a7b1b98c237c7e077079c6">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="classArray.html">Array</a>&lt; T, Capacity &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant pointer to the first element of the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Constant pointer to the first element of the vector </dd></dl>

</div>
</div>
<a id="a649850b709a4192a55176a58aa5a0e50" name="a649850b709a4192a55176a58aa5a0e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a649850b709a4192a55176a58aa5a0e50">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T const  * <a class="el" href="classArray.html">Array</a>&lt; T, Capacity &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant pointer to the first element of the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Constant pointer to the first element of the vector </dd></dl>

</div>
</div>
<a id="a8f7de134b93dbec27244349cdd10fd40" name="a8f7de134b93dbec27244349cdd10fd40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f7de134b93dbec27244349cdd10fd40">&#9670;&#160;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classArray.html">Array</a>&lt; T, Capacity &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum amount of elements that can currently be stored in the underlying data container. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum amount of items that can currently be stored in the underlying data container </dd></dl>

</div>
</div>
<a id="aeb279b27f54a2530575b51da33a15e0a" name="aeb279b27f54a2530575b51da33a15e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb279b27f54a2530575b51da33a15e0a">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T const  * <a class="el" href="classArray.html">Array</a>&lt; T, Capacity &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant pointer to the first element of the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Constant pointer to the first element of the vector </dd></dl>

</div>
</div>
<a id="a416f0777cffcd9cede627aaff0bbe6bb" name="a416f0777cffcd9cede627aaff0bbe6bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a416f0777cffcd9cede627aaff0bbe6bb">&#9670;&#160;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T const  * <a class="el" href="classArray.html">Array</a>&lt; T, Capacity &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant pointer to one-past-the-end element of the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Constant pointer to one-past-the-end element of the vector </dd></dl>

</div>
</div>
<a id="a77ee8f81241ce57ee65a3d979b807f56" name="a77ee8f81241ce57ee65a3d979b807f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77ee8f81241ce57ee65a3d979b807f56">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classArray.html">Array</a>&lt; T, Capacity &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the given underlying data container. Simply sets the underlying size to 0, data will only be cleared in the destructor. </p>

</div>
</div>
<a id="a8b56c91a89d22a430223dd43664b7def" name="a8b56c91a89d22a430223dd43664b7def"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b56c91a89d22a430223dd43664b7def">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classArray.html">Array</a>&lt; T, Capacity &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether there are still any element in the underlying data container. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether the underlying data container is empty or not </dd></dl>

</div>
</div>
<a id="ae0422f0975fa4bd276ef88866ec6ca1d" name="ae0422f0975fa4bd276ef88866ec6ca1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0422f0975fa4bd276ef88866ec6ca1d">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="classArray.html">Array</a>&lt; T, Capacity &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to one-past-the-end element of the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to one-past-the-end element of the vector </dd></dl>

</div>
</div>
<a id="a233404f5a66c7c2d434f60911bdccdd8" name="a233404f5a66c7c2d434f60911bdccdd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a233404f5a66c7c2d434f60911bdccdd8">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T const  * <a class="el" href="classArray.html">Array</a>&lt; T, Capacity &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant pointer to one-past-the-end element of the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Constant pointer to one-past-the-end element of the vector </dd></dl>

</div>
</div>
<a id="aa7371c9815908da4c7c44664b2be64d1" name="aa7371c9815908da4c7c44664b2be64d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7371c9815908da4c7c44664b2be64d1">&#9670;&#160;</a></span>erase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classArray.html">Array</a>&lt; T, Capacity &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">T const *const&#160;</td>
          <td class="paramname"><em>iterator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the element at the given iterator, has to move all element one to the left if the index is not at the end of the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterator</td><td>Iterator the element should be removed at from the underlying data container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac18f86feafd7b88f40dd631655716c13" name="ac18f86feafd7b88f40dd631655716c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac18f86feafd7b88f40dd631655716c13">&#9670;&#160;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classArray.html">Array</a>&lt; T, Capacity &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">T const *const&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const *const&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts all element from the given start to the given end iterator into the underlying data container. Simply calls push_back on each element, meaning if the initally allocated size if not big enough to hold all elements, then this method will simply not insert those elements instead. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Attribute is not used and can be left as nullptr, simply there to keep compatibility with std::vector insert method </td></tr>
    <tr><td class="paramname">first</td><td>Beginning of the elements we want to copy into our underlying data container </td></tr>
    <tr><td class="paramname">last</td><td>One past the end of the elements we want to copy into our underlying data container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a683e5ca9ab0b009eb1880fa20e7fca1e" name="a683e5ca9ab0b009eb1880fa20e7fca1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a683e5ca9ab0b009eb1880fa20e7fca1e">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classArray.html">Array</a>&lt; T, Capacity &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t const &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bracket operator to access an element at a given index. Does not do any bounds checks, meaning the access is more efficient but it is possible to read out of bounds data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index we want to get the corresponding element for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9c0d465703091b52d7ef1f51ab872be" name="aa9c0d465703091b52d7ef1f51ab872be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9c0d465703091b52d7ef1f51ab872be">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T const  &amp; <a class="el" href="classArray.html">Array</a>&lt; T, Capacity &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t const &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bracket operator to access an element at a given index. Does not do any bounds checks, meaning the access is more efficient but it is possible to read out of bounds data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index we want to get the corresponding element for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f8a222828c457b826642c8faa7d8feb" name="a7f8a222828c457b826642c8faa7d8feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f8a222828c457b826642c8faa7d8feb">&#9670;&#160;</a></span>push_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classArray.html">Array</a>&lt; T, Capacity &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the given element at the end of the underlying data container, If the interal data structure is full already then this method will assert and stop the application. Because if we do not we could cause an out of bounds write, which could possibly overwrite other memory. Causing hard to debug issues, therefore this behaviour is not allowed in the first place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>Element that should be inserted at the end </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9239d4fc1d30daeb07b6f2b5844fa97" name="aa9239d4fc1d30daeb07b6f2b5844fa97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9239d4fc1d30daeb07b6f2b5844fa97">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Capacity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t const  &amp; <a class="el" href="classArray.html">Array</a>&lt; T, Capacity &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the current amount of elements in the underlying data container. </p>
<dl class="section return"><dt>Returns</dt><dd>The amount of items currently in the underlying data container </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="Array_8h_source.html">Array.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
