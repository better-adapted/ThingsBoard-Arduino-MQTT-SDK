<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ThingsBoard Client SDK: IMQTT_Client Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">ThingsBoard Client SDK<span id="projectnumber">&#160;0.13.0</span>
   </div>
   <div id="projectbrief">Client SDK to connect with ThingsBoard IoT Platform from IoT devices (Arduino, Espressif, etc.)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classIMQTT__Client-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">IMQTT_Client Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>MQTT Client interface that contains the method that a class that can be used to send and receive data over an MQTT connection should implement. Seperates the specific implementation used from the ThingsBoard client, allows to use different clients depending on different needs. In this case the main use case of the seperation is to both support Espressif IDF and Arduino with the following libraries as recommendations. The default MQTT Client for Arduino is the PubSubClient forked from ThingsBoard (<a href="https://github.com/thingsboard/pubsubclient">https://github.com/thingsboard/pubsubclient</a>), it includes fixes to solve issues with using std::function callbacks for non ESP boards. For Espressif IDF however the default MQTT Client is the esp-mqtt (<a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/protocols/mqtt.html">https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/protocols/mqtt.html</a>) component. The aforementioned recommendations are already implemented in the library and can can simply be used and included when using the library, for Arduino we can simply include Arduino_MQTT_Client and for Espressif IDF we can simply include the Espressif_MQTT_Client, the implementations have been tested and should be compatible when used in conjunction with the ThingsBoard client. However when using an implementation that does not allow for Arduino it is additional important to disable support for THINGSBOARD_ENABLE_STREAM_UTILS, because this feature relies on Arduino as it improves the underlying data streams to directly write the data into the MQTT Client, but writing each byte one by one, would be too slow, therefore the ArduinoStreamUtils (<a href="https://github.com/bblanchon/ArduinoStreamUtils">https://github.com/bblanchon/ArduinoStreamUtils</a>) library is used to buffer those calls into bigger packets. This allows sending data that is very big without requiring to allocate that much memory, because it is sent in smaller packets. To support this feature, however this interface needs to additionally implement the Print interface, because that is required by the wrapper class BufferingPrint.  
 <a href="classIMQTT__Client.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="IMQTT__Client_8h_source.html">IMQTT_Client.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afc386851170b8d6866a017990385e57e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIMQTT__Client.html#afc386851170b8d6866a017990385e57e">data_function</a> = std::function&lt; void(char *topic, uint8_t *payload, unsigned int length)&gt;</td></tr>
<tr class="memdesc:afc386851170b8d6866a017990385e57e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classCallback.html" title="General purpose callback wrapper. Expects either c-style or c++ style function pointer,...">Callback</a> signature.  <a href="classIMQTT__Client.html#afc386851170b8d6866a017990385e57e">More...</a><br /></td></tr>
<tr class="separator:afc386851170b8d6866a017990385e57e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd2c2907eb184086a2ece927d2d6f955"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIMQTT__Client.html#abd2c2907eb184086a2ece927d2d6f955">connect_function</a> = std::function&lt; void(void)&gt;</td></tr>
<tr class="separator:abd2c2907eb184086a2ece927d2d6f955"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4c539aa3241efff6a45aea8bdc13e54b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIMQTT__Client.html#a4c539aa3241efff6a45aea8bdc13e54b">set_data_callback</a> (<a class="el" href="classIMQTT__Client.html#afc386851170b8d6866a017990385e57e">data_function</a> callback)=0</td></tr>
<tr class="memdesc:a4c539aa3241efff6a45aea8bdc13e54b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the callback that is called, if any message is received by the MQTT broker, including the topic string that the message was received over, as well as the payload data and the size of that payload data.  <a href="classIMQTT__Client.html#a4c539aa3241efff6a45aea8bdc13e54b">More...</a><br /></td></tr>
<tr class="separator:a4c539aa3241efff6a45aea8bdc13e54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221dd7883e517234453f37e03bd290b5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIMQTT__Client.html#a221dd7883e517234453f37e03bd290b5">set_connect_callback</a> (<a class="el" href="classIMQTT__Client.html#abd2c2907eb184086a2ece927d2d6f955">connect_function</a> callback)=0</td></tr>
<tr class="memdesc:a221dd7883e517234453f37e03bd290b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the callback that is called, if we have successfully established a connection with the MQTT broker.  <a href="classIMQTT__Client.html#a221dd7883e517234453f37e03bd290b5">More...</a><br /></td></tr>
<tr class="separator:a221dd7883e517234453f37e03bd290b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede3f3945520e064ebfc3d981eac9ebc"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIMQTT__Client.html#aede3f3945520e064ebfc3d981eac9ebc">set_buffer_size</a> (uint16_t const &amp;buffer_size)=0</td></tr>
<tr class="memdesc:aede3f3945520e064ebfc3d981eac9ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the size of the buffer for sent and received MQTT messages, using a bigger value than uint16_t for passing the buffer size does not make any sense because the maximum message size received or sent by MQTT can never be bigger than 64K, because it relies on TCP and the TCP size limit also uses a uint16_t internally for the size parameter.  <a href="classIMQTT__Client.html#aede3f3945520e064ebfc3d981eac9ebc">More...</a><br /></td></tr>
<tr class="separator:aede3f3945520e064ebfc3d981eac9ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d811f68debd8e10c59c0c239374751"><td class="memItemLeft" align="right" valign="top">virtual uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIMQTT__Client.html#a91d811f68debd8e10c59c0c239374751">get_buffer_size</a> ()=0</td></tr>
<tr class="memdesc:a91d811f68debd8e10c59c0c239374751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the previously set size of the internal buffer size for sent and received MQTT.  <a href="classIMQTT__Client.html#a91d811f68debd8e10c59c0c239374751">More...</a><br /></td></tr>
<tr class="separator:a91d811f68debd8e10c59c0c239374751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9729612931633f05fa3edef4958f901c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIMQTT__Client.html#a9729612931633f05fa3edef4958f901c">set_server</a> (char const *const domain, uint16_t const &amp;port)=0</td></tr>
<tr class="memdesc:a9729612931633f05fa3edef4958f901c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the server and port that the client should connect to MQTT over, should be called atleast once before calling <a class="el" href="classIMQTT__Client.html#af1c98db606348aa9592678fd935fb0d4" title="Connects to the previously with set_server configured server instance that should be connected to ove...">connect()</a> so it is clear which server to connect too.  <a href="classIMQTT__Client.html#a9729612931633f05fa3edef4958f901c">More...</a><br /></td></tr>
<tr class="separator:a9729612931633f05fa3edef4958f901c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c98db606348aa9592678fd935fb0d4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIMQTT__Client.html#af1c98db606348aa9592678fd935fb0d4">connect</a> (char const *const client_id, char const *const user_name, char const *const password)=0</td></tr>
<tr class="memdesc:af1c98db606348aa9592678fd935fb0d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connects to the previously with set_server configured server instance that should be connected to over the previously defined port.  <a href="classIMQTT__Client.html#af1c98db606348aa9592678fd935fb0d4">More...</a><br /></td></tr>
<tr class="separator:af1c98db606348aa9592678fd935fb0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05cb78386592aa959e1ba68131c7cf93"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIMQTT__Client.html#a05cb78386592aa959e1ba68131c7cf93">disconnect</a> ()=0</td></tr>
<tr class="memdesc:a05cb78386592aa959e1ba68131c7cf93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects from a previously connected server and should release all used resources.  <a href="classIMQTT__Client.html#a05cb78386592aa959e1ba68131c7cf93">More...</a><br /></td></tr>
<tr class="separator:a05cb78386592aa959e1ba68131c7cf93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14bf1e088f569976adfd524e029f9d23"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIMQTT__Client.html#a14bf1e088f569976adfd524e029f9d23">loop</a> ()=0</td></tr>
<tr class="memdesc:a14bf1e088f569976adfd524e029f9d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives and sends any outstanding messages from and to the MQTT broker.  <a href="classIMQTT__Client.html#a14bf1e088f569976adfd524e029f9d23">More...</a><br /></td></tr>
<tr class="separator:a14bf1e088f569976adfd524e029f9d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c9905a4fb0eec4d0b643993f62f3d3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIMQTT__Client.html#ab8c9905a4fb0eec4d0b643993f62f3d3">publish</a> (char const *const topic, uint8_t const *const payload, size_t const &amp;length)=0</td></tr>
<tr class="memdesc:ab8c9905a4fb0eec4d0b643993f62f3d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends the given payload over the previously established connection with connect.  <a href="classIMQTT__Client.html#ab8c9905a4fb0eec4d0b643993f62f3d3">More...</a><br /></td></tr>
<tr class="separator:ab8c9905a4fb0eec4d0b643993f62f3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af406f504a809043f3d29b87ed2fc6c4f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIMQTT__Client.html#af406f504a809043f3d29b87ed2fc6c4f">subscribe</a> (char const *const topic)=0</td></tr>
<tr class="memdesc:af406f504a809043f3d29b87ed2fc6c4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribes to MQTT message on the given topic, which will cause an internal callback to be called for each message received on that topic from the server, it should then, call the previously configured callback with <a class="el" href="classIMQTT__Client.html#a4c539aa3241efff6a45aea8bdc13e54b" title="Sets the callback that is called, if any message is received by the MQTT broker, including the topic ...">set_data_callback()</a> with the received data.  <a href="classIMQTT__Client.html#af406f504a809043f3d29b87ed2fc6c4f">More...</a><br /></td></tr>
<tr class="separator:af406f504a809043f3d29b87ed2fc6c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac844501e9be6d4d1700e36be79833693"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIMQTT__Client.html#ac844501e9be6d4d1700e36be79833693">unsubscribe</a> (char const *const topic)=0</td></tr>
<tr class="memdesc:ac844501e9be6d4d1700e36be79833693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribes to previously subscribed MQTT message on the given topic.  <a href="classIMQTT__Client.html#ac844501e9be6d4d1700e36be79833693">More...</a><br /></td></tr>
<tr class="separator:ac844501e9be6d4d1700e36be79833693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dfe357c2b35a844c9643d328af29ada"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIMQTT__Client.html#a9dfe357c2b35a844c9643d328af29ada">connected</a> ()=0</td></tr>
<tr class="memdesc:a9dfe357c2b35a844c9643d328af29ada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns our current connection status to MQTT, true meaning we are connected, false meaning we have been disconnected or have not established a connection yet.  <a href="classIMQTT__Client.html#a9dfe357c2b35a844c9643d328af29ada">More...</a><br /></td></tr>
<tr class="separator:a9dfe357c2b35a844c9643d328af29ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >MQTT Client interface that contains the method that a class that can be used to send and receive data over an MQTT connection should implement. Seperates the specific implementation used from the ThingsBoard client, allows to use different clients depending on different needs. In this case the main use case of the seperation is to both support Espressif IDF and Arduino with the following libraries as recommendations. The default MQTT Client for Arduino is the PubSubClient forked from ThingsBoard (<a href="https://github.com/thingsboard/pubsubclient">https://github.com/thingsboard/pubsubclient</a>), it includes fixes to solve issues with using std::function callbacks for non ESP boards. For Espressif IDF however the default MQTT Client is the esp-mqtt (<a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/protocols/mqtt.html">https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/protocols/mqtt.html</a>) component. The aforementioned recommendations are already implemented in the library and can can simply be used and included when using the library, for Arduino we can simply include Arduino_MQTT_Client and for Espressif IDF we can simply include the Espressif_MQTT_Client, the implementations have been tested and should be compatible when used in conjunction with the ThingsBoard client. However when using an implementation that does not allow for Arduino it is additional important to disable support for THINGSBOARD_ENABLE_STREAM_UTILS, because this feature relies on Arduino as it improves the underlying data streams to directly write the data into the MQTT Client, but writing each byte one by one, would be too slow, therefore the ArduinoStreamUtils (<a href="https://github.com/bblanchon/ArduinoStreamUtils">https://github.com/bblanchon/ArduinoStreamUtils</a>) library is used to buffer those calls into bigger packets. This allows sending data that is very big without requiring to allocate that much memory, because it is sent in smaller packets. To support this feature, however this interface needs to additionally implement the Print interface, because that is required by the wrapper class BufferingPrint. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="abd2c2907eb184086a2ece927d2d6f955" name="abd2c2907eb184086a2ece927d2d6f955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd2c2907eb184086a2ece927d2d6f955">&#9670;&#160;</a></span>connect_function</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classIMQTT__Client.html#abd2c2907eb184086a2ece927d2d6f955">IMQTT_Client::connect_function</a> =  std::function&lt;void(void)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afc386851170b8d6866a017990385e57e" name="afc386851170b8d6866a017990385e57e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc386851170b8d6866a017990385e57e">&#9670;&#160;</a></span>data_function</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classIMQTT__Client.html#afc386851170b8d6866a017990385e57e">IMQTT_Client::data_function</a> =  std::function&lt;void(char * topic, uint8_t * payload, unsigned int length)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classCallback.html" title="General purpose callback wrapper. Expects either c-style or c++ style function pointer,...">Callback</a> signature. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af1c98db606348aa9592678fd935fb0d4" name="af1c98db606348aa9592678fd935fb0d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1c98db606348aa9592678fd935fb0d4">&#9670;&#160;</a></span>connect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool IMQTT_Client::connect </td>
          <td>(</td>
          <td class="paramtype">char const *const&#160;</td>
          <td class="paramname"><em>client_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *const&#160;</td>
          <td class="paramname"><em>user_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *const&#160;</td>
          <td class="paramname"><em>password</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connects to the previously with set_server configured server instance that should be connected to over the previously defined port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client_id</td><td>Client identification code, that allows to differentiate which MQTT device is sending the traffic to the MQTT broker </td></tr>
    <tr><td class="paramname">user_name</td><td>Client username that is used to authenticate, who is connecting over MQTT </td></tr>
    <tr><td class="paramname">password</td><td>Client password that is used to authenticate, who is connecting over MQTT </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the client could establish the connection successfully or not </dd></dl>

</div>
</div>
<a id="a9dfe357c2b35a844c9643d328af29ada" name="a9dfe357c2b35a844c9643d328af29ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dfe357c2b35a844c9643d328af29ada">&#9670;&#160;</a></span>connected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool IMQTT_Client::connected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns our current connection status to MQTT, true meaning we are connected, false meaning we have been disconnected or have not established a connection yet. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether the client is currently connected or not </dd></dl>

</div>
</div>
<a id="a05cb78386592aa959e1ba68131c7cf93" name="a05cb78386592aa959e1ba68131c7cf93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05cb78386592aa959e1ba68131c7cf93">&#9670;&#160;</a></span>disconnect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IMQTT_Client::disconnect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disconnects from a previously connected server and should release all used resources. </p>

</div>
</div>
<a id="a91d811f68debd8e10c59c0c239374751" name="a91d811f68debd8e10c59c0c239374751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91d811f68debd8e10c59c0c239374751">&#9670;&#160;</a></span>get_buffer_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint16_t IMQTT_Client::get_buffer_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the previously set size of the internal buffer size for sent and received MQTT. </p>
<dl class="section return"><dt>Returns</dt><dd>Internal size of the buffer </dd></dl>

</div>
</div>
<a id="a14bf1e088f569976adfd524e029f9d23" name="a14bf1e088f569976adfd524e029f9d23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14bf1e088f569976adfd524e029f9d23">&#9670;&#160;</a></span>loop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool IMQTT_Client::loop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receives and sends any outstanding messages from and to the MQTT broker. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether sending or receiving the oustanding the messages was successful or not, should return false if an internal error occured or the connection has been lost </dd></dl>

</div>
</div>
<a id="ab8c9905a4fb0eec4d0b643993f62f3d3" name="ab8c9905a4fb0eec4d0b643993f62f3d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8c9905a4fb0eec4d0b643993f62f3d3">&#9670;&#160;</a></span>publish()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool IMQTT_Client::publish </td>
          <td>(</td>
          <td class="paramtype">char const *const&#160;</td>
          <td class="paramname"><em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t const *const&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t const &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends the given payload over the previously established connection with connect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic</td><td>Topic that the message is sent over, where different MQTT topics expect a different kind of payload </td></tr>
    <tr><td class="paramname">payload</td><td>Payload containg the json data that should be sent </td></tr>
    <tr><td class="paramname">length</td><td>Length of the payload in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether publishing the payload on the given topic was successful or not </dd></dl>

</div>
</div>
<a id="aede3f3945520e064ebfc3d981eac9ebc" name="aede3f3945520e064ebfc3d981eac9ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aede3f3945520e064ebfc3d981eac9ebc">&#9670;&#160;</a></span>set_buffer_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool IMQTT_Client::set_buffer_size </td>
          <td>(</td>
          <td class="paramtype">uint16_t const &amp;&#160;</td>
          <td class="paramname"><em>buffer_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the size of the buffer for sent and received MQTT messages, using a bigger value than uint16_t for passing the buffer size does not make any sense because the maximum message size received or sent by MQTT can never be bigger than 64K, because it relies on TCP and the TCP size limit also uses a uint16_t internally for the size parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer_size</td><td>Maximum amount of data that can be either received or sent via MQTT at once, expected behaviour is that, if bigger packets are received they are discarded and a warning is printed to the console and if we attempt to send data that is bigger, it will simply not be sent and a message is printed to the console instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether allocating the needed memory for the given buffer_size was successful or not </dd></dl>

</div>
</div>
<a id="a221dd7883e517234453f37e03bd290b5" name="a221dd7883e517234453f37e03bd290b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a221dd7883e517234453f37e03bd290b5">&#9670;&#160;</a></span>set_connect_callback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IMQTT_Client::set_connect_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIMQTT__Client.html#abd2c2907eb184086a2ece927d2d6f955">connect_function</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the callback that is called, if we have successfully established a connection with the MQTT broker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Method that should be called on established MQTT connection </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c539aa3241efff6a45aea8bdc13e54b" name="a4c539aa3241efff6a45aea8bdc13e54b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c539aa3241efff6a45aea8bdc13e54b">&#9670;&#160;</a></span>set_data_callback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IMQTT_Client::set_data_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIMQTT__Client.html#afc386851170b8d6866a017990385e57e">data_function</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the callback that is called, if any message is received by the MQTT broker, including the topic string that the message was received over, as well as the payload data and the size of that payload data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Method that should be called on received MQTT response </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9729612931633f05fa3edef4958f901c" name="a9729612931633f05fa3edef4958f901c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9729612931633f05fa3edef4958f901c">&#9670;&#160;</a></span>set_server()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IMQTT_Client::set_server </td>
          <td>(</td>
          <td class="paramtype">char const *const&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t const &amp;&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Configures the server and port that the client should connect to MQTT over, should be called atleast once before calling <a class="el" href="classIMQTT__Client.html#af1c98db606348aa9592678fd935fb0d4" title="Connects to the previously with set_server configured server instance that should be connected to ove...">connect()</a> so it is clear which server to connect too. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>Server instance name the client should connect too </td></tr>
    <tr><td class="paramname">port</td><td>Port that will be used to establish a connection and send / receive data Should be either 1883 for unencrypted MQTT or 8883 for MQTT with TLS/SSL encryption. The latter is recommended if relevant data is sent or if the client receives and handles Remote Procedure Calls or Shared Attribute Update Callbacks from the server, because using an unencrpyted connection, will allow 3rd parties to listen to the communication and impersonate the server sending payloads which might influence the device in unexpected ways. However if Over the Air udpates are enabled secure communication should definetly be enabled, because if that is not done a 3rd party might impersonate the server sending a malicious payload, which is then flashed onto the device instead of the real firmware. Which depeding on the payload might even be able to destroy the device or make it otherwise unusable. See <a href="https://stackoverflow.blog/2020/12/14/security-considerations-for-ota-software-updates-for-iot-gateway-devices/">https://stackoverflow.blog/2020/12/14/security-considerations-for-ota-software-updates-for-iot-gateway-devices/</a> for more information on the aforementioned security risk </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af406f504a809043f3d29b87ed2fc6c4f" name="af406f504a809043f3d29b87ed2fc6c4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af406f504a809043f3d29b87ed2fc6c4f">&#9670;&#160;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool IMQTT_Client::subscribe </td>
          <td>(</td>
          <td class="paramtype">char const *const&#160;</td>
          <td class="paramname"><em>topic</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscribes to MQTT message on the given topic, which will cause an internal callback to be called for each message received on that topic from the server, it should then, call the previously configured callback with <a class="el" href="classIMQTT__Client.html#a4c539aa3241efff6a45aea8bdc13e54b" title="Sets the callback that is called, if any message is received by the MQTT broker, including the topic ...">set_data_callback()</a> with the received data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic</td><td>Topic we want to receive a notification about if messages are sent by the server </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Wheter subscribing the given topic was possible or not, should return false and a warning should be printed, if the connection has been lost or the topic does not exist </dd></dl>

</div>
</div>
<a id="ac844501e9be6d4d1700e36be79833693" name="ac844501e9be6d4d1700e36be79833693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac844501e9be6d4d1700e36be79833693">&#9670;&#160;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool IMQTT_Client::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">char const *const&#160;</td>
          <td class="paramname"><em>topic</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribes to previously subscribed MQTT message on the given topic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic</td><td>Topic we want to stop receiving a notification about if messages are sent by the server </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Wheter unsubscribing the given topic was possible or not, should return false and a warning should be printed, if the connection has been lost or the topic was not previously subscribed </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="IMQTT__Client_8h_source.html">IMQTT_Client.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
