<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ThingsBoard Client SDK: Callback_Watchdog Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">ThingsBoard Client SDK<span id="projectnumber">&#160;0.13.0</span>
   </div>
   <div id="projectbrief">Client SDK to connect with ThingsBoard IoT Platform from IoT devices (Arduino, Espressif, etc.)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classCallback__Watchdog-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Callback_Watchdog Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Wrapper class which allows to start a timer and if it is not stopped in the given time then the callback that was passed will be called, which informs the user of the failure to stop the timer in time, meaning a timeout has occured. The class wraps around either the Arduino Ticker class from Arduino (<a href="https://github.com/sstaub/Ticker">https://github.com/sstaub/Ticker</a>) or the offical ESP Timer implementation from Espressif (<a href="https://github.com/espressif/esp-idf/tree/2bc1f2f574/examples/system/esp_timer">https://github.com/espressif/esp-idf/tree/2bc1f2f574/examples/system/esp_timer</a>), the latter takes precendence if it exists. This is done because the usage is more efficient, under the hood we simply start and then stop and if needed start a oneshot timer again. When using the esp timer directly the same timer can be reused to stop and start and therefore does not need to create a new timer everytime, the Ticker in comparsion automatically deletes a timer once it has been stopped and we therefore need to create it again once the timer is started. This causes a lot of overhead therefore if the esp timer exists we do not use the Ticker class but instead the esp timer directly. For all other use cases where the esp timer does not exists we instead use the Ticker as a fallback, because in that case its implementation is completly different anyway. The class instance is meant to be started with <a class="el" href="classCallback__Watchdog.html#a7b43283565b9e874b335c318eadc79d9" title="Starts the watchdog timer once for the given timeout.">once()</a> which will then call the registered callback after the timeout has passed, if the <a class="el" href="classCallback__Watchdog.html#a833d862e5d64fe89cbe30383bf9b5032" title="Stops the currently ongoing watchdog timer and ensures the callback is not called....">detach()</a> method has not been called yet. This results in behaviour similair to a esp task watchdog but without as high of an accuracy and without restarting the device, allowing to let it fail and handle the error case silently by the user in the callback method. Documentation about the specific use and caviates of the ESP Timer implementation can be found here <a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/system/esp_timer.html">https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/system/esp_timer.html</a>.  
 <a href="classCallback__Watchdog.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Callback__Watchdog_8h_source.html">Callback_Watchdog.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a48019589a9db7ea992399b0a6fb321e9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallback__Watchdog.html#a48019589a9db7ea992399b0a6fb321e9">Callback_Watchdog</a> (std::function&lt; void(void)&gt; callback)</td></tr>
<tr class="memdesc:a48019589a9db7ea992399b0a6fb321e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classCallback__Watchdog.html#a48019589a9db7ea992399b0a6fb321e9">More...</a><br /></td></tr>
<tr class="separator:a48019589a9db7ea992399b0a6fb321e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c03783fd4f5148c6accfde7fc034f4a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallback__Watchdog.html#a2c03783fd4f5148c6accfde7fc034f4a">~Callback_Watchdog</a> ()</td></tr>
<tr class="memdesc:a2c03783fd4f5148c6accfde7fc034f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classCallback__Watchdog.html#a2c03783fd4f5148c6accfde7fc034f4a">More...</a><br /></td></tr>
<tr class="separator:a2c03783fd4f5148c6accfde7fc034f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b43283565b9e874b335c318eadc79d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallback__Watchdog.html#a7b43283565b9e874b335c318eadc79d9">once</a> (uint64_t const &amp;timeout_microseconds)</td></tr>
<tr class="memdesc:a7b43283565b9e874b335c318eadc79d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the watchdog timer once for the given timeout.  <a href="classCallback__Watchdog.html#a7b43283565b9e874b335c318eadc79d9">More...</a><br /></td></tr>
<tr class="separator:a7b43283565b9e874b335c318eadc79d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833d862e5d64fe89cbe30383bf9b5032"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCallback__Watchdog.html#a833d862e5d64fe89cbe30383bf9b5032">detach</a> ()</td></tr>
<tr class="memdesc:a833d862e5d64fe89cbe30383bf9b5032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the currently ongoing watchdog timer and ensures the callback is not called. Timer can simply be restarted with calling <a class="el" href="classCallback__Watchdog.html#a7b43283565b9e874b335c318eadc79d9" title="Starts the watchdog timer once for the given timeout.">once()</a> again.  <a href="classCallback__Watchdog.html#a833d862e5d64fe89cbe30383bf9b5032">More...</a><br /></td></tr>
<tr class="separator:a833d862e5d64fe89cbe30383bf9b5032"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Wrapper class which allows to start a timer and if it is not stopped in the given time then the callback that was passed will be called, which informs the user of the failure to stop the timer in time, meaning a timeout has occured. The class wraps around either the Arduino Ticker class from Arduino (<a href="https://github.com/sstaub/Ticker">https://github.com/sstaub/Ticker</a>) or the offical ESP Timer implementation from Espressif (<a href="https://github.com/espressif/esp-idf/tree/2bc1f2f574/examples/system/esp_timer">https://github.com/espressif/esp-idf/tree/2bc1f2f574/examples/system/esp_timer</a>), the latter takes precendence if it exists. This is done because the usage is more efficient, under the hood we simply start and then stop and if needed start a oneshot timer again. When using the esp timer directly the same timer can be reused to stop and start and therefore does not need to create a new timer everytime, the Ticker in comparsion automatically deletes a timer once it has been stopped and we therefore need to create it again once the timer is started. This causes a lot of overhead therefore if the esp timer exists we do not use the Ticker class but instead the esp timer directly. For all other use cases where the esp timer does not exists we instead use the Ticker as a fallback, because in that case its implementation is completly different anyway. The class instance is meant to be started with <a class="el" href="classCallback__Watchdog.html#a7b43283565b9e874b335c318eadc79d9" title="Starts the watchdog timer once for the given timeout.">once()</a> which will then call the registered callback after the timeout has passed, if the <a class="el" href="classCallback__Watchdog.html#a833d862e5d64fe89cbe30383bf9b5032" title="Stops the currently ongoing watchdog timer and ensures the callback is not called....">detach()</a> method has not been called yet. This results in behaviour similair to a esp task watchdog but without as high of an accuracy and without restarting the device, allowing to let it fail and handle the error case silently by the user in the callback method. Documentation about the specific use and caviates of the ESP Timer implementation can be found here <a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/system/esp_timer.html">https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/system/esp_timer.html</a>. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a48019589a9db7ea992399b0a6fb321e9" name="a48019589a9db7ea992399b0a6fb321e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48019589a9db7ea992399b0a6fb321e9">&#9670;&#160;</a></span>Callback_Watchdog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Callback_Watchdog::Callback_Watchdog </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(void)&gt;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td><a class="el" href="classCallback.html" title="General purpose callback wrapper. Expects either c-style or c++ style function pointer,...">Callback</a> method that will be called if the timeout time passes without <a class="el" href="classCallback__Watchdog.html#a833d862e5d64fe89cbe30383bf9b5032" title="Stops the currently ongoing watchdog timer and ensures the callback is not called....">detach()</a> being called </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c03783fd4f5148c6accfde7fc034f4a" name="a2c03783fd4f5148c6accfde7fc034f4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c03783fd4f5148c6accfde7fc034f4a">&#9670;&#160;</a></span>~Callback_Watchdog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Callback_Watchdog::~Callback_Watchdog </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a833d862e5d64fe89cbe30383bf9b5032" name="a833d862e5d64fe89cbe30383bf9b5032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a833d862e5d64fe89cbe30383bf9b5032">&#9670;&#160;</a></span>detach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Callback_Watchdog::detach </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops the currently ongoing watchdog timer and ensures the callback is not called. Timer can simply be restarted with calling <a class="el" href="classCallback__Watchdog.html#a7b43283565b9e874b335c318eadc79d9" title="Starts the watchdog timer once for the given timeout.">once()</a> again. </p>

</div>
</div>
<a id="a7b43283565b9e874b335c318eadc79d9" name="a7b43283565b9e874b335c318eadc79d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b43283565b9e874b335c318eadc79d9">&#9670;&#160;</a></span>once()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Callback_Watchdog::once </td>
          <td>(</td>
          <td class="paramtype">uint64_t const &amp;&#160;</td>
          <td class="paramname"><em>timeout_microseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts the watchdog timer once for the given timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_microseconds</td><td>Amount of microseconds until the <a class="el" href="classCallback__Watchdog.html#a833d862e5d64fe89cbe30383bf9b5032" title="Stops the currently ongoing watchdog timer and ensures the callback is not called....">detach()</a> method is excpected to have been called or the initally given callback method will be called </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="Callback__Watchdog_8h_source.html">Callback_Watchdog.h</a></li>
<li>src/<a class="el" href="Callback__Watchdog_8cpp.html">Callback_Watchdog.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
